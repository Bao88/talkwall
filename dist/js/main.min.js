/// <reference path="../../typings/index.d.ts"/>
/// <reference path="_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    configApp.$inject = ['$translateProvider', '$httpProvider', '$routeProvider'];
    /**
     * Application-wide overall configuration
     * @param $translateProvider  Used for defining default language translation support.
     * @param $httpProvider  Used for registering an interceptor (TokenInterceptor).
     * @param $routeProvider  Used for defining default routing.
     */
    function configApp($translateProvider, $httpProvider, $routeProvider) {
        // Routes
        $routeProvider.
            when('/wall', {
            templateUrl: 'js/components/wall/wall.html'
        })
            .when('/', {
            templateUrl: 'js/components/landing/landing.html'
        });
        // Token interceptor
        $httpProvider.interceptors.push('TokenInterceptor');
        // Translation
        $translateProvider.useSanitizeValueStrategy('escaped');
        $translateProvider.useStaticFilesLoader({
            prefix: './languages/',
            suffix: '.json'
        });
    }
    TalkwallApp.configApp = configApp;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    runApp.$inject = ['$rootScope'];
    function runApp($rootScope) {
        console.log('--> runApp started');
    }
    TalkwallApp.runApp = runApp;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var URLService = (function () {
        function URLService($location) {
            this.$location = $location;
            this.languageDomain = 'en';
            if (this.$location.host().indexOf('.no') > -1) {
                this.languageDomain = 'no';
            }
            console.log('--> URLService started ... the locale used is: ' + this.languageDomain);
        }
        URLService.prototype.getLanguageDomain = function () {
            return this.languageDomain;
        };
        URLService.prototype.getHost = function () {
            return this.$location.protocol() + '://' + this.$location.host() + ':' + this.$location.port();
        };
        URLService.$inject = ["$location"];
        return URLService;
    }());
    TalkwallApp.URLService = URLService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var AuthenticationService = (function () {
        function AuthenticationService() {
            this._isAuthenticated = false;
        }
        Object.defineProperty(AuthenticationService.prototype, "isAuthenticated", {
            get: function () {
                return this._isAuthenticated;
            },
            set: function (value) {
                this._isAuthenticated = value;
            },
            enumerable: true,
            configurable: true
        });
        return AuthenticationService;
    }());
    TalkwallApp.AuthenticationService = AuthenticationService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var UtilityService = (function () {
        function UtilityService() {
            console.log('--> UtilityService started ...');
        }
        UtilityService.prototype.v4 = function () {
            var id = '', i;
            for (i = 0; i < 36; i++) {
                if (i === 14) {
                    id += '4';
                }
                else if (i === 19) {
                    id += '89ab'.charAt(this.getRandom(4));
                }
                else if (i === 8 || i === 13 || i === 18 || i === 23) {
                    id += '-';
                }
                else {
                    id += '0123456789abcdef'.charAt(this.getRandom(16));
                }
            }
            return id;
        };
        UtilityService.prototype.getRandom = function (max) {
            return Math.random() * max;
        };
        UtilityService.prototype.getRandomBetween = function (min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        };
        return UtilityService;
    }());
    TalkwallApp.UtilityService = UtilityService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var User = (function () {
        function User() {
        }
        return User;
    }());
    TalkwallApp.User = User;
    var Wall = (function () {
        function Wall() {
        }
        // Return the Question for the given question ID
        Wall.prototype.getQuestionById = function (id) {
            this.questions.forEach(function (q) {
                if (q._id === id) {
                    return q;
                }
            });
            return null;
        };
        // Return the index of the given question ID
        Wall.prototype.getQuestionIndexById = function (id) {
            this.questions.forEach(function (q, index) {
                if (q._id === id) {
                    return index;
                }
            });
            return -1;
        };
        return Wall;
    }());
    TalkwallApp.Wall = Wall;
    var Question = (function () {
        function Question(label) {
            this.label = label;
            this.messages = [];
        }
        return Question;
    }());
    TalkwallApp.Question = Question;
    var Message = (function () {
        function Message() {
            this.createdAt = new Date();
            this.deleted = false;
            this.text = '';
            this.origin = [];
            this.edits = [];
            this.board = {};
        }
        return Message;
    }());
    TalkwallApp.Message = Message;
    var PollUpdate = (function () {
        function PollUpdate() {
        }
        return PollUpdate;
    }());
    TalkwallApp.PollUpdate = PollUpdate;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="urlservice.ts"/>
/// <reference path="authenticationservice.ts"/>
/// <reference path="utilityservice.ts"/>
/// <reference path="urlservice.ts"/>
/// <reference path="../models/models.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var DataService = (function () {
        function DataService($http, $window, $routeParams, $location, $interval, utilityService, urlService) {
            this.$http = $http;
            this.$window = $window;
            this.$routeParams = $routeParams;
            this.$location = $location;
            this.$interval = $interval;
            this.utilityService = utilityService;
            this.urlService = urlService;
            this.user = null;
            this.wall = null;
            this.question = null;
            this.messageToEdit = new TalkwallApp.Message();
            //for dev only
            this.studentNickname = null;
            this.participants = [];
            this.userAuthorised = false;
            console.log('--> DataService started ...');
        }
        // Remove token string from the address bar. Then, if authorised, get the user model and the most recent wall
        // Otherwise, follow on back to where we came from..
        DataService.prototype.checkAuthentication = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            var tKey = 'authenticationToken', tokenKey = 'token';
            var tokenParam = this.$routeParams[tKey] || '';
            if (tokenParam !== '') {
                //look at the route params first for 'authenticationToken'
                console.log('--> DataService: token from parameter');
                this.$window.sessionStorage[tokenKey] = tokenParam;
                //this will reload the page, clearing the token parameter. next time around it will hit the next 'else if'
                this.$location.search(tKey, null);
            }
            else if (this.$window.sessionStorage[tokenKey]) {
                this.userAuthorised = true;
                //look at the window session object for the token. time to load the question
                console.log('--> DataService: token already existing');
                this.requestUser(function (user) {
                    if (user.lastOpenedWall === null) {
                        _this.createWall(successCallbackFn, errorCallbackFn);
                    }
                    else {
                        _this.requestWall(user.lastOpenedWall, successCallbackFn, errorCallbackFn);
                    }
                }, function (error) {
                    //TODO: handle get user error
                });
            }
            else {
                // Fall through..
                successCallbackFn();
            }
        };
        DataService.prototype.requestUser = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            //this will return the correct user from the service, based on the req.user object.
            this.$http.get(this.urlService.getHost() + '/user')
                .success(function (data) {
                var resultKey = 'result';
                _this.user = data[resultKey];
                console.log('--> DataService: getUser success');
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.user);
                }
            })
                .catch(function (error) {
                console.log('--> DataService: getUser failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.requestWall = function (wallId, successCallbackFn, errorCallbackFn) {
            var _this = this;
            //return the previous wall with a the existing PIN from REDIS (if expired return true)
            this.$http.get(this.urlService.getHost() + '/wall/' + wallId)
                .success(function (data) {
                var resultKey = 'result';
                _this.wall = data[resultKey];
                console.log('--> DataService: getWall success');
                _this.setQuestion(0, successCallbackFn, errorCallbackFn);
            })
                .catch(function (error) {
                console.log('--> DataService: getWall failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.createWall = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            this.$http.post(this.urlService.getHost() + '/wall', { label: "New Wall: " + new Date().toDateString() })
                .success(function (data) {
                var resultKey = 'result';
                _this.wall = data[resultKey];
                console.log('--> DataService: getWall success');
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.wall);
                }
            })
                .catch(function (error) {
                console.log('--> DataService: getWall failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.joinWall = function (joinModel, successCallbackFn, errorCallbackFn) {
            var _this = this;
            this.$http.get(this.urlService.getHost() + '/join/' + joinModel.nickname + '/' + joinModel.pin)
                .success(function (data) {
                var resultKey = 'result';
                _this.wall = data[resultKey];
                console.log('--> DataService: getWall success');
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.wall);
                }
            })
                .catch(function (error) {
                console.log('--> DataService: getWall failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        // Accessor functions for passing messages between directives
        DataService.prototype.setMessageToEdit = function (message) {
            this.messageToEdit = message;
        };
        DataService.prototype.getMessageToEdit = function () {
            return this.messageToEdit;
        };
        DataService.prototype.userIsAuthorised = function () {
            return this.userAuthorised;
        };
        DataService.prototype.getWall = function () {
            return this.wall;
        };
        DataService.prototype.getQuestion = function () {
            return this.question;
        };
        // If we are changing questions, set the polling params correctly
        DataService.prototype.setQuestion = function (questionIndex, successCallbackFn, errorCallbackFn) {
            var previous_question_id = 'none', control = 'none';
            // If true, we are changing questions
            if (this.question !== null && this.wall.questions.indexOf(this.question) !== questionIndex) {
                previous_question_id = this.question._id;
                control = 'change';
            }
            else if (this.question === null) {
                control = 'new';
            } // Otherwise, we continue to poll the same question
            this.question = this.wall.questions[questionIndex];
            this.stopPolling();
            this.startPolling(previous_question_id, control);
            if (typeof successCallbackFn === "function") {
                successCallbackFn(this.wall);
            }
        };
        DataService.prototype.getNickname = function () {
            if (this.userAuthorised) {
                return this.user.nickname;
            }
            else {
                return this.studentNickname;
            }
        };
        // Set previousQuestionIndex if we are changing questions. Else set it to -1
        DataService.prototype.requestPoll = function (previousQuestionId, control, successCallbackFn, errorCallbackFn) {
            var _this = this;
            this.$http.get(this.urlService.getHost() + '/poll/' + this.getNickname() + '/' + this.wall._id +
                '/' + this.question._id + '/' + previousQuestionId + '/' + control)
                .success(function (data) {
                var resultKey = 'result';
                _this.processUpdatedMessages(data[resultKey]);
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            })
                .catch(function (error) {
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        //generate a new question on server with _id and returns it
        DataService.prototype.addQuestion = function (label, successCallbackFn, errorCallbackFn) {
            var _this = this;
            var question = new TalkwallApp.Question(label);
            this.$http.post(this.urlService.getHost() + '/question', { wall_id: this.wall._id, question: question })
                .success(function (data) {
                var resultKey = 'result';
                question.createdAt = data[resultKey].createdAt;
                question._id = data[resultKey]._id;
                _this.wall.questions.push(question);
                _this.question = question;
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(question);
                }
            })
                .catch(function (error) {
                console.log('--> DataService: getQuestion failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        //generate a new message on server with _id and returns it
        DataService.prototype.addMessage = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            var nickname = this.getNickname();
            if (this.messageToEdit === null) {
                errorCallbackFn({ status: '400', message: "message is not defined" });
            }
            this.messageToEdit.creator = this.getNickname();
            this.messageToEdit.origin.push({ nickname: this.messageToEdit.creator, message_id: this.messageToEdit._id });
            this.messageToEdit.edits.push({ date: this.messageToEdit.createdAt, text: this.messageToEdit.text });
            this.$http.post(this.urlService.getHost() + '/message', {
                message: this.messageToEdit,
                pin: this.wall.pin,
                nickname: nickname
            })
                .success(function (data) {
                var resultKey = 'result';
                _this.messageToEdit.createdAt = data[resultKey].createdAt;
                _this.messageToEdit._id = data[resultKey]._id;
                _this.question.messages.push(_this.messageToEdit);
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.messageToEdit);
                }
            })
                .catch(function (error) {
                console.log('--> DataService: getQuestion failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        //update a new on server and return it
        DataService.prototype.updateMessage = function (successCallbackFn, errorCallbackFn) {
            if (this.messageToEdit === null) {
                errorCallbackFn({ status: '400', message: "message is not defined" });
            }
            this.$http.put(this.urlService.getHost() + '/message', {
                message: this.messageToEdit,
                pin: this.wall.pin,
                nickname: this.getNickname()
            })
                .success(function (data) {
                var resultKey = 'result';
                var message = data[resultKey];
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(message);
                }
            })
                .catch(function (error) {
                console.log('--> DataService: getQuestion failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        /*
        deleteMessage(successCallbackFn, errorCallbackFn): void {
            //update message on server with _id and returns it
            // this.$http.put('message.json')
            //on response, update the feed
            /*let idKey = '_id';
             for (var i = 0; i < this.question.messageFeed.length; i++) {
             if (this.question.messageFeed[i][idKey] === message._id) {
             this.question.messageFeed.splice(i, 1);
             this.question.messageFeed.splice(i, 0, message);
             }
             }
            //if we get a 200 response we are happy, nothing to do
            successCallbackFn();
        }
        */
        DataService.prototype.setBoardDivSize = function (newSize) {
            console.log('--> Dataservice: setBoardDivSize: ' + angular.toJson(newSize));
            this.boardDivSize = newSize;
        };
        DataService.prototype.getBoardDivSize = function () {
            return this.boardDivSize;
        };
        //  Run the polling timer
        // 'previous_question_id' can be an empty string if not changing questions
        // 'control' this is a regular poll 'none', the first poll 'new', or we are changing questions 'change'
        DataService.prototype.startPolling = function (previous_question_id, control) {
            var _this = this;
            // Don't allow more than one timer
            if (angular.isDefined(this.timerHandle)) {
                return;
            }
            // Make the special request without delay, and set up regular polling
            this.requestPoll(previous_question_id, control, function (success) {
                // Begin further requests at time intervals
                _this.timerHandle = _this.$interval(function () {
                    _this.requestPoll('none', 'none', null, null);
                }, 5000);
            }, null);
        };
        // Stop the polling timer
        DataService.prototype.stopPolling = function () {
            if (angular.isDefined(this.timerHandle)) {
                this.$interval.cancel(this.timerHandle);
                this.timerHandle = undefined;
            }
        };
        // Process updated messages retrieved on the poll response
        DataService.prototype.processUpdatedMessages = function (pollUpdateObject) {
            // Status updates
            // Update participant list
            this.participants = pollUpdateObject.status.connected_nicknames;
            // Change questions if directed by the update
            if (pollUpdateObject.status.select_question_id !== this.question._id) {
                this.setQuestion(this.wall.getQuestionIndexById(pollUpdateObject.status.select_question_id), null, null);
            }
            // Message updates
            pollUpdateObject.messages.forEach(function (message) {
                console.log('Message from: ' + message.creator + ' : ' + message.text);
            });
        };
        DataService.$inject = ['$http', '$window', '$routeParams', '$location', '$interval', 'UtilityService', 'URLService'];
        return DataService;
    }());
    TalkwallApp.DataService = DataService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="authenticationservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var TokenInterceptor = (function () {
        function TokenInterceptor($q, $window, $location, authenticationService) {
            var _this = this;
            this.$q = $q;
            this.$window = $window;
            this.$location = $location;
            this.authenticationService = authenticationService;
            this.request = function (config) {
                var tKey = 'token', aKey = 'Authorization';
                config.headers = config.headers || {};
                if (_this.$window.sessionStorage[tKey]) {
                    config.headers[aKey] = 'Bearer ' + _this.$window.sessionStorage[tKey];
                }
                return config;
            };
            this.requestError = function (rejection) {
                return _this.$q.reject(rejection);
            };
            this.response = function (response) {
                var tKey = 'token', sKey = 'status';
                if (response !== null && response[sKey] === 200 && _this.$window.sessionStorage[tKey]
                    && !_this.authenticationService.isAuthenticated) {
                    _this.authenticationService.isAuthenticated = true;
                    console.log('TokenInterceptor: client already authenticated: ' + _this.$window.sessionStorage[tKey]);
                }
                return response || _this.$q.when(response);
            };
            this.responseError = function (rejection) {
                var tKey = 'token';
                if (rejection !== null && rejection.status === 401 && (_this.$window.sessionStorage[tKey]
                    || _this.authenticationService.isAuthenticated)) {
                    delete _this.$window.sessionStorage[tKey];
                    _this.authenticationService.isAuthenticated = false;
                    console.log('TokenInterceptor: client NOT authenticated');
                    _this.$location.path("/login");
                }
                return _this.$q.reject(rejection);
            };
            console.log('--> ITokenInterceptor started ...');
        }
        TokenInterceptor.$inject = ['$q', '$window', '$location', 'AuthenticationService'];
        return TokenInterceptor;
    }());
    TalkwallApp.TokenInterceptor = TokenInterceptor;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    AutoResize.$inject = ['$window'];
    function AutoResize($window) {
        var link = function (scope, element, attrs) {
            function initializeWindowSize() {
                var mhKey = 'maxHeight', whKey = 'windowHeight', wwKey = 'windowWidth';
                scope[mhKey] = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight, window.innerHeight);
                scope[whKey] = $window.innerHeight;
                scope[wwKey] = $window.innerWidth;
            }
            initializeWindowSize();
            scope.$watch('__height', function () {
                initializeWindowSize();
            });
            angular.element($window).bind('resize', function () {
                initializeWindowSize();
                return scope.$apply();
            });
        };
        return {
            link: link
        };
    }
    TalkwallApp.AutoResize = AutoResize;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../models/models.ts"/>
/// <reference path="../../services/dataservice.ts"/>
/// <reference path="../../services/utilityservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var FeedMessageController = (function () {
        function FeedMessageController(isolatedScope, dataService, $document, utilityService, $timeout) {
            this.isolatedScope = isolatedScope;
            this.dataService = dataService;
            this.$document = $document;
            this.utilityService = utilityService;
            this.$timeout = $timeout;
            this.showControls = false;
            this.message = isolatedScope.data;
        }
        ;
        /**
         * init
         */
        FeedMessageController.prototype.activate = function () {
            console.log('--> FeedMessageController activated');
            this.message.isPinned = false;
            if (this.message.board[this.dataService.getNickname()] !== undefined) {
                this.message.isSelected = true;
                if (this.message.board[this.dataService.getNickname()].pinned === true) {
                    this.message.isPinned = false;
                }
            }
            else {
                this.message.isSelected = false;
            }
        };
        FeedMessageController.prototype.deleteMessage = function () {
            this.dataService.setMessageToEdit(this.message);
            this.message.deleted = true;
            this.dataService.updateMessage(function () {
                //success delete
            }, function (error) {
                //TODO: handle message delete error
            });
        };
        FeedMessageController.prototype.editMessage = function () {
            this.dataService.setMessageToEdit(this.message);
            this.isolatedScope.showEditPanel();
        };
        FeedMessageController.prototype.selectMessage = function () {
            var handle = this;
            this.message.board[this.dataService.getNickname()] = {
                xpos: handle.utilityService.getRandomBetween(45, 55) / 100,
                ypos: handle.utilityService.getRandomBetween(45, 55) / 100,
                pinned: false
            };
            this.dataService.setMessageToEdit(this.message);
            this.dataService.updateMessage(function () {
                handle.message.isSelected = true;
                handle.dataService.setMessageToEdit(null);
            }, function (error) {
                //TODO: handle message POST error
            });
        };
        FeedMessageController.prototype.unselectMessage = function () {
            var handle = this;
            delete this.message.board[this.dataService.getNickname()];
            this.message.isPinned = false;
            this.dataService.setMessageToEdit(this.message);
            this.dataService.updateMessage(function () {
                handle.message.isSelected = false;
                handle.dataService.setMessageToEdit(null);
            }, function (error) {
                //TODO: handle message POST error
            });
        };
        FeedMessageController.prototype.pinMessage = function () {
            var handle = this;
            this.message.board[this.dataService.getNickname()].pinned = true;
            this.dataService.setMessageToEdit(this.message);
            this.dataService.updateMessage(function () {
                handle.message.isPinned = true;
                handle.dataService.setMessageToEdit(null);
            }, function (error) {
                //TODO: handle message POST error
            });
        };
        FeedMessageController.prototype.unpinMessage = function () {
            var handle = this;
            this.message.board[this.dataService.getNickname()].pinned = false;
            this.dataService.setMessageToEdit(this.message);
            this.dataService.updateMessage(function () {
                handle.message.isPinned = false;
                handle.dataService.setMessageToEdit(null);
            }, function (error) {
                //TODO: handle message POST error
            });
        };
        FeedMessageController.$inject = ['$scope', 'DataService', '$document', 'UtilityService', '$timeout'];
        return FeedMessageController;
    }());
    function linker(isolatedScope, element, attributes, ctrl) {
        var viewWidthKey = 'VIEW_WIDTH', viewHeightKey = 'VIEW_HEIGHT';
        var changedTouchesKey = 'changedTouches';
        var startX = 0, startY = 0;
        if (isolatedScope.onBoard === 'true') {
            var messageWidth = element.prop('offsetWidth');
            var messageHeight = element.prop('offsetHeight');
            var currentSize = ctrl.dataService.getBoardDivSize();
            element.css({
                top: isolatedScope.data.board[ctrl.dataService.getNickname()].ypos * 100 + '%',
                left: isolatedScope.data.board[ctrl.dataService.getNickname()].xpos * 100 + '%'
            });
            element.on('mousedown touchstart', function (event) {
                // Prevent default dragging of selected content
                event.preventDefault();
                currentSize = ctrl.dataService.getBoardDivSize();
                messageWidth = element.prop('offsetWidth');
                messageHeight = element.prop('offsetHeight');
                if (event instanceof TouchEvent) {
                    // Handling the touchstart event
                    var touchobj = event[changedTouchesKey][0];
                    startX = touchobj.clientX;
                    startY = touchobj.clientY;
                    ctrl.$document.on('touchmove', touchmove);
                    ctrl.$document.on('touchend', touchend);
                }
                else if (event instanceof MouseEvent) {
                    // Handling the mousedown event
                    startX = event.screenX - (isolatedScope.data.board[ctrl.dataService.getNickname()].xpos * currentSize[viewWidthKey]);
                    startY = event.screenY - (isolatedScope.data.board[ctrl.dataService.getNickname()].ypos * currentSize[viewHeightKey]);
                    ctrl.$document.on('mousemove', mousemove);
                    ctrl.$document.on('mouseup', mouseup);
                }
            });
        }
        function mousemove(event) {
            isolatedScope.data.board[ctrl.dataService.getNickname()].xpos = event.screenX - startX;
            isolatedScope.data.board[ctrl.dataService.getNickname()].ypos = event.screenY - startY;
            doMove();
        }
        function touchmove(event) {
            var touchobj = event[changedTouchesKey][0];
            isolatedScope.data.board[ctrl.dataService.getNickname()].xpos = touchobj.pageX - startX;
            isolatedScope.data.board[ctrl.dataService.getNickname()].ypos = touchobj.pageY - startY;
            doMove();
        }
        function doMove() {
            if (isolatedScope.data.board[ctrl.dataService.getNickname()].xpos < 0) {
                isolatedScope.data.board[ctrl.dataService.getNickname()].xpos = 0;
            }
            if (isolatedScope.data.board[ctrl.dataService.getNickname()].xpos > (currentSize[viewWidthKey] - messageWidth)) {
                isolatedScope.data.board[ctrl.dataService.getNickname()].xpos = (currentSize[viewWidthKey] - messageWidth);
            }
            if (isolatedScope.data.board[ctrl.dataService.getNickname()].ypos < 0) {
                isolatedScope.data.board[ctrl.dataService.getNickname()].ypos = 0;
            }
            if (isolatedScope.data.board[ctrl.dataService.getNickname()].ypos > (currentSize[viewHeightKey] - messageHeight)) {
                isolatedScope.data.board[ctrl.dataService.getNickname()].ypos = (currentSize[viewHeightKey] - messageHeight);
            }
            element.css({
                top: isolatedScope.data.board[ctrl.dataService.getNickname()].ypos + 'px',
                left: isolatedScope.data.board[ctrl.dataService.getNickname()].xpos + 'px'
            });
            isolatedScope.data.board[ctrl.dataService.getNickname()].xpos =
                isolatedScope.data.board[ctrl.dataService.getNickname()].xpos / currentSize[viewWidthKey];
            isolatedScope.data.board[ctrl.dataService.getNickname()].ypos =
                isolatedScope.data.board[ctrl.dataService.getNickname()].ypos / currentSize[viewHeightKey];
        }
        function mouseup() {
            ctrl.$document.off('mousemove', mousemove);
            ctrl.$document.off('mouseup', mouseup);
        }
        function touchend() {
            ctrl.$document.off('touchmove', touchmove);
            ctrl.$document.off('touchend', touchend);
        }
    }
    //directive declaration
    function FeedMessage() {
        return {
            restrict: 'A',
            scope: {
                data: '=',
                showEditPanel: "&",
                onBoard: "@"
            },
            templateUrl: 'js/components/feedMessage/feedMessage.html',
            controller: FeedMessageController,
            controllerAs: 'feedMessageC',
            link: linker,
            replace: true
        };
    }
    TalkwallApp.FeedMessage = FeedMessage;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var WatchBoardSizeController = (function () {
        function WatchBoardSizeController(dataService, $window) {
            this.dataService = dataService;
            this.$window = $window;
        }
        ;
        WatchBoardSizeController.$inject = ['DataService', '$window'];
        return WatchBoardSizeController;
    }());
    function linker(scope, element, attrs, ctrl) {
        var w = angular.element(ctrl.$window);
        scope.getWindowDimensions = function () {
            return {
                'VIEW_HEIGHT': element.prop('offsetHeight'),
                'VIEW_WIDTH': element.prop('offsetWidth')
            };
        };
        scope.$watch(scope.getWindowDimensions, function (newValue, oldValue) {
            ctrl.dataService.setBoardDivSize(newValue);
        }, true);
        w.bind('resize', function () {
            scope.$apply();
        });
        ctrl.dataService.setBoardDivSize(scope.getWindowDimensions());
    }
    function WatchBoardSize() {
        return {
            restrict: 'A',
            controller: WatchBoardSizeController,
            link: linker
        };
    }
    TalkwallApp.WatchBoardSize = WatchBoardSize;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var LoginController = (function () {
        function LoginController($mdDialog) {
            this.$mdDialog = $mdDialog;
            console.log('--> LoginController: started: ');
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        LoginController.prototype.hide = function (response) {
            console.log('--> LoginController: hide');
            this.$mdDialog.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        LoginController.prototype.cancel = function (response) {
            console.log('--> LoginController: cancel');
            this.$mdDialog.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        LoginController.prototype.answer = function (answer) {
            console.log('--> LoginController: answer: ' + answer);
            this.$mdDialog.hide(answer);
        };
        ;
        LoginController.$inject = ['$mdDialog'];
        return LoginController;
    }());
    TalkwallApp.LoginController = LoginController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var JoinController = (function () {
        function JoinController($mdDialog) {
            this.$mdDialog = $mdDialog;
            this.joinModel = {
                nickname: "",
                pin: NaN
            };
            console.log('--> LoginController: started: ');
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        JoinController.prototype.hide = function (response) {
            console.log('--> JoinController: hide');
            this.$mdDialog.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        JoinController.prototype.cancel = function (response) {
            console.log('--> JoinController: cancel');
            this.$mdDialog.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        JoinController.prototype.answer = function () {
            if (this.joinModel.nickname.length > 0 && this.joinModel.pin > 999 && this.joinModel.pin < 10000) {
                this.$mdDialog.hide(this.joinModel);
            }
        };
        ;
        JoinController.$inject = ['$mdDialog'];
        return JoinController;
    }());
    TalkwallApp.JoinController = JoinController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../login/login.ts"/>
/// <reference path="../join/join.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var LandingController = (function () {
        function LandingController(urlService, $translate, $mdMedia, $mdDialog, $window, dataService) {
            this.urlService = urlService;
            this.$translate = $translate;
            this.$mdMedia = $mdMedia;
            this.$mdDialog = $mdDialog;
            this.$window = $window;
            this.dataService = dataService;
            console.log('--> LandingController: started');
            this.$translate.use(this.urlService.getLanguageDomain());
            this.customFullscreen = this.$mdMedia('xs') || this.$mdMedia('sm');
        }
        /**
         * display an advanced dialog for the login, and catches it's events
         */
        LandingController.prototype.showLoginDialog = function (ev) {
            var handle = this;
            //detects if the device is small
            var useFullScreen = (this.$mdMedia('sm') || this.$mdMedia('xs')) && this.customFullscreen;
            //show the dialog
            this.$mdDialog.show({
                controller: TalkwallApp.LoginController,
                controllerAs: 'loginC',
                templateUrl: 'js/components/login/login.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                clickOutsideToClose: true
            })
                .then(function (answer) {
                //dialog answered
                console.log('--> LandingController: answer: ' + answer);
                handle.$window.location.href = handle.urlService.getHost() + answer;
            }, function () {
                //dialog dismissed
                console.log('--> LandingController: dismissed');
            });
        };
        ;
        /**
         * display dialog for joining with pin and nickname
         */
        LandingController.prototype.showJoinDialog = function (ev) {
            var handle = this;
            //detects if the device is small
            var useFullScreen = (this.$mdMedia('sm') || this.$mdMedia('xs')) && this.customFullscreen;
            //show the dialog
            this.$mdDialog.show({
                controller: TalkwallApp.JoinController,
                controllerAs: 'joinC',
                templateUrl: 'js/components/join/join.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                clickOutsideToClose: true
            })
                .then(function (joinModel) {
                handle.dataService.joinWall(joinModel, function () {
                    handle.$window.location.href = handle.urlService.getHost() + '/#/wall';
                }, null);
            }, function () {
                //dialog dismissed
                console.log('--> LandingController: dismissed');
            });
        };
        LandingController.$inject = ['URLService', '$translate', '$mdMedia', '$mdDialog', '$window', 'DataService'];
        return LandingController;
    }());
    TalkwallApp.LandingController = LandingController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var EditMessageController = (function () {
        function EditMessageController($mdBottomSheet, dataService) {
            this.$mdBottomSheet = $mdBottomSheet;
            this.dataService = dataService;
            console.log('--> EditMessageController: started: ');
            this.messageToEdit = dataService.getMessageToEdit();
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        EditMessageController.prototype.hide = function (response) {
            console.log('--> EditMessageController: hide');
            this.$mdBottomSheet.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        EditMessageController.prototype.cancel = function (response) {
            console.log('--> EditMessageController: cancel');
            this.$mdBottomSheet.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        EditMessageController.prototype.answer = function (answer) {
            console.log('--> EditMessageController: answer: ' + answer);
            if (answer !== undefined) {
                this.$mdBottomSheet.hide(answer);
            }
            else {
                this.$mdBottomSheet.cancel();
            }
        };
        ;
        EditMessageController.$inject = ['$mdBottomSheet', 'DataService'];
        return EditMessageController;
    }());
    TalkwallApp.EditMessageController = EditMessageController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../../services/dataservice.ts"/>
/// <reference path="../editMessagePanel/editMessagePanel.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var WallController = (function () {
        function WallController(dataService, $mdSidenav, $mdBottomSheet) {
            var _this = this;
            this.dataService = dataService;
            this.$mdSidenav = $mdSidenav;
            this.$mdBottomSheet = $mdBottomSheet;
            this.magnified = false;
            this.feedView = true;
            this.rightMenu1 = false;
            this.rightMenu2 = false;
            this.rightMenu3 = false;
            this.newQuestionLabel = '';
            /*private currentWall: Wall;
            private currentQuestion: Question = null;*/
            this.currentQuestionIndex = 0;
            this.viewHeight = 700;
            this.viewWidth = 1200;
            console.log('--> WallController: started: ');
            this.dataService.checkAuthentication(function (success) {
                _this.activate();
            }, null);
        }
        WallController.prototype.activate = function () {
            if (this.dataService.getWall().questions.length > 0) {
                this.setQuestion(this.currentQuestionIndex); // Select first question, no previous question
            }
            if (this.dataService.userIsAuthorised()) {
                this.rightMenu2 = true;
                this.$mdSidenav('right').open();
            }
        };
        WallController.prototype.setQuestion = function (questionIndex) {
            var _this = this;
            this.dataService.setQuestion(questionIndex, function () {
                //success
                _this.currentQuestionIndex = questionIndex;
            }, function () {
                //error
            });
        };
        WallController.prototype.showMessageEditor = function (newMessage) {
            var handle = this;
            if (newMessage) {
                handle.dataService.setMessageToEdit(new TalkwallApp.Message());
            }
            this.messageToEdit = handle.dataService.getMessageToEdit();
            this.$mdSidenav('left').open();
            this.$mdBottomSheet.show({
                controller: TalkwallApp.EditMessageController,
                controllerAs: 'editMessageC',
                templateUrl: 'js/components/editMessagePanel/editMessagePanel.html'
            }).then(function (answer) {
                //dialog answered
                console.log('--> WallController: answer: ' + answer);
                //post message to server and add returned object to question feed
                if (newMessage) {
                    handle.dataService.addMessage(function () {
                        //success
                    }, function (error) {
                        //TODO: handle message POST error
                    });
                }
                else {
                    handle.dataService.updateMessage(null, null);
                }
            }, function () {
                //dialog dismissed
                console.log('--> WallController: dismissed');
            });
        };
        WallController.prototype.toggleRightMenu = function (n) {
            console.log('--> WallController: toggleRightMenu: ' + n);
            switch (n) {
                case 1:
                    this.rightMenu1 = !this.rightMenu1;
                    this.rightMenu2 = false;
                    this.rightMenu3 = false;
                    break;
                case 2:
                    this.rightMenu1 = false;
                    this.rightMenu2 = !this.rightMenu2;
                    this.rightMenu3 = false;
                    break;
                case 3:
                    this.rightMenu1 = false;
                    this.rightMenu2 = false;
                    this.rightMenu3 = !this.rightMenu3;
                    break;
                default:
                    this.rightMenu1 = false;
                    this.rightMenu2 = false;
                    this.rightMenu3 = false;
            }
        };
        WallController.prototype.postNewQuestion = function () {
            var _this = this;
            this.dataService.addQuestion(this.newQuestionLabel, function (success) {
                _this.newQuestionLabel = '';
                //set the current question if none
                if (_this.dataService.getQuestion() === null) {
                    _this.setQuestion(_this.currentQuestionIndex);
                }
            }, function (error) {
                //TODO: handle question retrieval error
            });
        };
        WallController.$inject = ['DataService', '$mdSidenav', '$mdBottomSheet'];
        return WallController;
    }());
    TalkwallApp.WallController = WallController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="_references.ts"/>
/// <reference path="app.config.ts"/>
/// <reference path="services/dataservice.ts"/>
/// <reference path="services/authenticationservice.ts"/>
/// <reference path="services/tokenservice.ts"/>
/// <reference path="services/urlservice.ts"/>
/// <reference path="services/utilityservice.ts"/>
/// <reference path="directives/autoresize.ts"/>
/// <reference path="components/feedMessage/feedMessage.ts"/>
/// <reference path="directives/watchboardsize.ts"/>
/// <reference path="components/login/login.ts"/>
/// <reference path="components/join/join.ts"/>
/// <reference path="components/landing/landing.ts"/>
/// <reference path="components/wall/wall.ts"/>
/// <reference path="components/editMessagePanel/editMessagePanel.ts"/>
/// <reference path="app.run.ts"/>
/**
 * TalkwallApp core application module.
 * @preferred
 */
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    /**
     * Array of dependencies to be injected in the application "dependencies".
     */
    var dependencies = [
        'ngRoute',
        'ngAria',
        'ngAnimate',
        'pascalprecht.translate',
        'ngMaterial'
    ];
    angular.module('TalkwallApp', dependencies)
        .config(TalkwallApp.configApp)
        .service('URLService', TalkwallApp.URLService)
        .service('DataService', TalkwallApp.DataService)
        .service('AuthenticationService', TalkwallApp.AuthenticationService)
        .service('TokenInterceptor', TalkwallApp.TokenInterceptor)
        .service('UtilityService', TalkwallApp.UtilityService)
        .directive('autoresize', TalkwallApp.AutoResize)
        .directive('watchBoardSize', TalkwallApp.WatchBoardSize)
        .directive('feedMessage', TalkwallApp.FeedMessage)
        .controller('LoginController', TalkwallApp.LoginController)
        .controller('JoinController', TalkwallApp.JoinController)
        .controller('LandingController', TalkwallApp.LandingController)
        .controller('WallController', TalkwallApp.WallController)
        .controller('EditMessageController', TalkwallApp.EditMessageController)
        .run(TalkwallApp.runApp);
})(TalkwallApp || (TalkwallApp = {}));
