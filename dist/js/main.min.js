/// <reference path="../../typings/index.d.ts"/>
/// <reference path="_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    configApp.$inject = ['$translateProvider', '$httpProvider', '$routeProvider'];
    /**
     * Application-wide overall configuration
     * @param $translateProvider  Used for defining default language translation support.
     * @param $httpProvider  Used for registering an interceptor (TokenInterceptor).
     * @param $routeProvider  Used for defining default routing.
     */
    function configApp($translateProvider, $httpProvider, $routeProvider) {
        // Routes
        $routeProvider.
            when('/export', {
            templateUrl: 'js/components/export/export.html'
        })
            .when('/id', {
            templateUrl: 'js/components/sessioninfo/sessioninfo.html'
        })
            .when('/wall', {
            templateUrl: 'js/components/wall/wall.html'
        })
            .when('/', {
            templateUrl: 'js/components/landing/landing.html'
        });
        // Token interceptor
        $httpProvider.interceptors.push('TokenInterceptor');
        // Translation
        $translateProvider.useSanitizeValueStrategy('escaped');
        $translateProvider.useStaticFilesLoader({
            prefix: './languages/',
            suffix: '.json'
        });
        var lang = null;
        var languagesKey = 'languages';
        var langKey = 'lang';
        if (navigator[languagesKey]) {
            lang = navigator[languagesKey][0];
        }
        else {
            lang = navigator.language || navigator['userLanguage'];
        }
        if (lang.indexOf('no') > -1 || lang.indexOf('nb') > -1) {
            $translateProvider.preferredLanguage('no');
            sessionStorage[langKey] = 'no';
        }
        else {
            $translateProvider.preferredLanguage('en');
            sessionStorage[langKey] = 'en';
        }
    }
    TalkwallApp.configApp = configApp;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path='_references.ts'/>
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    var TalkwallConstants = (function () {
        function TalkwallConstants() {
        }
        Object.defineProperty(TalkwallConstants, "constants", {
            get: function () {
                return {
                    POLL_INTERVAL_SECONDS: 5,
                    POLLS_PER_LOG_ATTEMPT: 5,
                    /****  Colours animated from wall.scss  References are here  */
                    BACKGROUND_COLOURS: ['bg1', 'bg2', 'bg3', 'bg4', 'bg5', 'bg6', 'bg7', 'bg8', 'bg9'],
                    // BACKGROUND_COLOURS: ["#5E7E98", "#666666", "#6D8565", "#7A7A7A", "#828565", "#858585", "#8EBEE6",
                    //    "#998C5F", "#999999", "#ABD19F"],
                    COMPLEMENTARY_COLOURS: ['#FFFFF5', '#FFFFF5', '#FFFFF5', '#FFFFF5', '#FFFFF5', '#FFFFF5', '#FFFFF5',
                        '#FFFFF5', '#FFFFF5', '#FFFFF5']
                };
            },
            enumerable: true,
            configurable: true
        });
        ;
        return TalkwallConstants;
    }());
    TalkwallApp.TalkwallConstants = TalkwallConstants;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    runApp.$inject = ['$rootScope'];
    function runApp($rootScope) {
        console.log('--> runApp started');
    }
    TalkwallApp.runApp = runApp;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var URLService = (function () {
        function URLService($location) {
            this.$location = $location;
            console.log('--> URLService started ... ');
        }
        URLService.prototype.getHost = function () {
            if (this.$location.port() === 80) {
                return this.$location.protocol() + '://' + this.$location.host();
            }
            else {
                return this.$location.protocol() + '://' + this.$location.host() + ':' + this.$location.port();
            }
        };
        URLService.$inject = ['$location'];
        return URLService;
    }());
    TalkwallApp.URLService = URLService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var AuthenticationService = (function () {
        function AuthenticationService() {
            this._isAuthenticated = false;
        }
        Object.defineProperty(AuthenticationService.prototype, "isAuthenticated", {
            get: function () {
                return this._isAuthenticated;
            },
            set: function (value) {
                this._isAuthenticated = value;
            },
            enumerable: true,
            configurable: true
        });
        return AuthenticationService;
    }());
    TalkwallApp.AuthenticationService = AuthenticationService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var LogType = (function () {
        function LogType() {
        }
        LogType.CreateMessage = "mc";
        LogType.EditMessage = "me";
        LogType.PinMessage = "mp";
        LogType.UnPinMessage = "mup";
        LogType.DeleteMessage = "md";
        LogType.HighlightMessage = "mh";
        LogType.UnHighlightMessage = "muh";
        LogType.MoveMessage = "mm";
        LogType.CreateTask = "tc";
        LogType.EditTask = "te";
        LogType.DeleteTask = "td";
        return LogType;
    }());
    TalkwallApp.LogType = LogType;
    var User = (function () {
        function User() {
        }
        return User;
    }());
    TalkwallApp.User = User;
    var Wall = (function () {
        function Wall() {
        }
        return Wall;
    }());
    TalkwallApp.Wall = Wall;
    var Question = (function () {
        function Question(label) {
            this.label = label;
            this.grid = 'none';
            this.messages = [];
            this.showControls = false;
            this.createdAt = new Date();
            this.contributors = [];
            this.isNew = false;
        }
        Question.prototype.updateMe = function (newQuestion) {
            if (typeof newQuestion === 'undefined') {
                return;
            }
            this._id = newQuestion['_id'];
            this.createdAt = newQuestion['createdAt'];
            this.label = newQuestion['label'];
            this.grid = newQuestion['grid'];
            if (typeof newQuestion['contributors'] !== 'undefined' && newQuestion['contributors'] !== null) {
                this.contributors = newQuestion['contributors'];
            }
            return this;
        };
        return Question;
    }());
    TalkwallApp.Question = Question;
    /* Sub classes for Message */
    var Nickname = (function () {
        function Nickname(x, y, highlighted) {
            this.xpos = x;
            this.ypos = y;
            this.highlighted = highlighted;
        }
        Nickname.prototype.updateMe = function (x, y, highlighted) {
            this.xpos = x;
            this.ypos = y;
            this.highlighted = highlighted;
        };
        return Nickname;
    }());
    TalkwallApp.Nickname = Nickname;
    var Message = (function () {
        function Message() {
            this.createdAt = new Date();
            this.deleted = false;
            this.text = '';
            this.origin = [];
            this.edits = [];
            this.board = {};
            this.isHighlighted = false;
        }
        Message.prototype.createFromOrigin = function (originMessage, newNickname) {
            // no _id until sent to server
            var _this = this;
            this.text = originMessage.text;
            this.creator = newNickname;
            this.question_id = originMessage.question_id;
            originMessage.origin.forEach(function (origin) {
                _this.origin.push(origin);
            });
            this.origin.push({ nickname: newNickname, message_id: originMessage._id });
            this.origin.reverse();
            if (typeof originMessage.board[newNickname] !== 'undefined') {
                this.board[newNickname] = new Nickname(originMessage.board['xpos'], originMessage.board['ypos'], originMessage.board['highlighted']);
            }
            return this;
        };
        Message.prototype.updateMe = function (newMessage) {
            this._id = newMessage['_id'];
            this.createdAt = newMessage['createdAt'];
            this.deleted = newMessage['deleted'];
            this.creator = newMessage['creator'];
            this.text = newMessage['text'];
            this.question_id = newMessage['question_id'];
            if (typeof newMessage['board'] !== 'undefined' && newMessage['board'] !== null) {
                this.updateBoard(newMessage['board'], false, '');
            }
            else {
                // Remove all nicknames
                for (var nickname in this.board) {
                    if (this.board.hasOwnProperty(nickname)) {
                        delete this.board[nickname];
                    }
                }
            }
            if (typeof newMessage['origin'] !== 'undefined' && newMessage['origin'] !== null) {
                this.origin = newMessage['origin'];
            }
            if (typeof newMessage['edits'] !== 'undefined' && newMessage['edits'] !== null) {
                this.edits = newMessage['edits'];
            }
            return this;
        };
        // If updateMyself is true, include my nickname in the update
        Message.prototype.updateBoard = function (newBoard, excludeMyself, myNickname) {
            for (var nickname in newBoard) {
                if ((!excludeMyself || nickname !== myNickname) && newBoard.hasOwnProperty(nickname)) {
                    // Update an existing nickname
                    if (this.board.hasOwnProperty(nickname)) {
                        this.board[nickname].updateMe(newBoard[nickname]['xpos'], newBoard[nickname]['ypos'], newBoard[nickname]['highlighted']);
                    }
                    else {
                        this.board[nickname] = new Nickname(newBoard[nickname]['xpos'], newBoard[nickname]['ypos'], newBoard[nickname]['highlighted']);
                    }
                }
            }
            // Remove nicknames no longer in the updated message, except my own as only I can remove it from my board
            for (var nickname in this.board) {
                if (this.board.hasOwnProperty(nickname) && !newBoard.hasOwnProperty(nickname) && nickname !== myNickname) {
                    delete this.board[nickname];
                }
            }
        };
        return Message;
    }());
    TalkwallApp.Message = Message;
    // Queues contain only the modifiable data needed
    var UpdatedQueueItem = (function () {
        function UpdatedQueueItem() {
        }
        return UpdatedQueueItem;
    }());
    TalkwallApp.UpdatedQueueItem = UpdatedQueueItem;
    var CreatedQueueItem = (function () {
        function CreatedQueueItem() {
        }
        return CreatedQueueItem;
    }());
    TalkwallApp.CreatedQueueItem = CreatedQueueItem;
    // Class used to send and respond with status & message updates through polling
    var PollUpdate = (function () {
        // set status to PollUpdate('', false) to prevent any status update on server
        function PollUpdate(question_id) {
            this.totalOnTalkwall = 0;
            this.status = {
                last_update: Date.now(),
                last_access: Date.now(),
                teacher_current_question: question_id,
                connected_teachers: [],
                connected_students: [],
                idleTerminationTime: 0
            };
            this.created = {};
            this.updated = {};
        }
        return PollUpdate;
    }());
    TalkwallApp.PollUpdate = PollUpdate;
    var LogEntry = (function () {
        function LogEntry(type, id, nickname, question_id, diff) {
            this.q_id = question_id;
            this.type = type;
            this.itemid = id;
            this.nick = nickname;
            if (diff !== null) {
                this.diff = diff;
            }
            else {
                this.diff = null;
            }
            this.stamp = new Date();
        }
        return LogEntry;
    }());
    TalkwallApp.LogEntry = LogEntry;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="../models/models.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var UtilityService = (function () {
        function UtilityService() {
            console.log('--> UtilityService started ...');
        }
        UtilityService.prototype.v4 = function () {
            var id = '', i;
            for (i = 0; i < 36; i++) {
                if (i === 14) {
                    id += '4';
                }
                else if (i === 19) {
                    id += '89ab'.charAt(UtilityService.getRandom(4));
                }
                else if (i === 8 || i === 13 || i === 18 || i === 23) {
                    id += '-';
                }
                else {
                    id += '0123456789abcdef'.charAt(UtilityService.getRandom(16));
                }
            }
            return id;
        };
        UtilityService.getRandom = function (max) {
            return Math.random() * max;
        };
        UtilityService.getFormattedDate = function (date) {
            if (date !== null) {
                return moment(date).format('DD/MM/YYYY - HH:mm');
            }
        };
        UtilityService.prototype.getRandomBetween = function (min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        };
        UtilityService.prototype.removeNullIn = function (prop, obj) {
            var pr = obj[prop];
            if (pr === null || pr === undefined) {
                delete obj[prop];
            }
            else if (typeof pr === 'object') {
                for (var i in pr) {
                    if (pr.hasOwnProperty(i)) {
                        this.removeNullIn(i, pr);
                    }
                }
            }
        };
        UtilityService.prototype.removeNull = function (obj) {
            for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    this.removeNullIn(i, obj);
                }
            }
        };
        // Return the Message from a Question for the given message ID and question
        UtilityService.prototype.getMessageFromQuestionById = function (id, question) {
            var message = null;
            question.messages.forEach(function (m) {
                if (m._id === id) {
                    message = m;
                }
            });
            return message;
        };
        ;
        // Return the index of the given question ID on a wall
        UtilityService.getQuestionIndexFromWallById = function (id, wall) {
            for (var i = 0; i < wall.questions.length; i++) {
                if (wall.questions[i]._id === id) {
                    return i;
                }
            }
            return -1;
        };
        UtilityService.prototype.getPossibleTags = function (content) {
            var tags = null, filteredTags = [];
            if (content !== undefined) {
                /* tslint:disable */
                tags = content.match(/#\S+/gi);
                if (tags !== null) {
                    tags.forEach(function (tag) {
                        var lowerTag = tag.toLowerCase();
                        if (filteredTags.indexOf(lowerTag) === -1) {
                            filteredTags.push(lowerTag);
                        }
                    });
                }
            }
            return filteredTags;
        };
        return UtilityService;
    }());
    TalkwallApp.UtilityService = UtilityService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var CloseController = (function () {
        function CloseController($mdDialog) {
            this.$mdDialog = $mdDialog;
            this.theanswer = {
                answered: true
            };
            console.log('--> LoginController: started: ');
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        CloseController.prototype.hide = function (response) {
            console.log('--> JoinController: hide');
            this.$mdDialog.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        CloseController.prototype.cancel = function (response) {
            console.log('--> JoinController: cancel');
            this.$mdDialog.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        CloseController.prototype.answer = function () {
            this.$mdDialog.hide(this.theanswer);
        };
        ;
        CloseController.$inject = ['$mdDialog'];
        return CloseController;
    }());
    TalkwallApp.CloseController = CloseController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var ArchiveWallController = (function () {
        function ArchiveWallController($mdDialog, dataService) {
            this.$mdDialog = $mdDialog;
            this.dataService = dataService;
            this.showInput = false;
            this.owneremail = undefined;
            console.log('--> LoginController: started: ');
            if (this.dataService.getAuthenticatedUser().defaultEmail !== undefined && this.dataService.getAuthenticatedUser().defaultEmail !== '') {
                this.owneremail = this.dataService.getAuthenticatedUser().defaultEmail;
            }
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        ArchiveWallController.prototype.hide = function (response) {
            console.log('--> ArchiveWallController: hide');
            this.$mdDialog.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        ArchiveWallController.prototype.cancel = function (response) {
            console.log('--> ArchiveWallController: cancel');
            this.$mdDialog.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        ArchiveWallController.prototype.answer = function (answer) {
            console.log('--> ArchiveWallController: answer: ' + answer);
            this.$mdDialog.hide(answer);
        };
        ;
        ArchiveWallController.$inject = ['$mdDialog', 'DataService'];
        return ArchiveWallController;
    }());
    TalkwallApp.ArchiveWallController = ArchiveWallController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="../app.constants.ts"/>
/// <reference path="urlservice.ts"/>
/// <reference path="authenticationservice.ts"/>
/// <reference path="utilityservice.ts"/>
/// <reference path="urlservice.ts"/>
/// <reference path="../components/close/close.ts"/>
/// <reference path="../components/archive/archive.ts"/>
/// <reference path="../models/models.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var DataService = (function () {
        function DataService($http, $window, $routeParams, $rootScope, $location, $interval, $timeout, $mdDialog, $translate, utilityService, urlService, $mdMedia, constants) {
            var _this = this;
            this.$http = $http;
            this.$window = $window;
            this.$routeParams = $routeParams;
            this.$rootScope = $rootScope;
            this.$location = $location;
            this.$interval = $interval;
            this.$timeout = $timeout;
            this.$mdDialog = $mdDialog;
            this.$translate = $translate;
            this.utilityService = utilityService;
            this.urlService = urlService;
            this.$mdMedia = $mdMedia;
            this.constants = constants;
            this.noTag = 'no tag';
            this.pollingTimerHandle = null;
            this.restrictTimerHandle = null;
            this.logCycleCounter = 0;
            this.data = {
                user: null,
                wall: null,
                question: null,
                status: {
                    joinedWithPin: false,
                    authorised: false,
                    nickname: null,
                    participants: [],
                    totalOnTalkwall: 0,
                    selectedParticipant: null,
                    questionToEdit: null,
                    messageToEdit: null,
                    messageOrigin: null,
                    updateOrigin: false,
                    currentQuestionIndex: -1,
                    phoneMode: false,
                    contributors: [],
                    unselected_contributors: [],
                    tags: [],
                    unselected_tags: [],
                    tagCounter: {},
                    boardDivSize: {},
                    last_status_update: 0,
                    touchControl: false,
                    magnifyBoard: false,
                    restrictPositionRequests: false,
                    restrictPositionRequestMessages: {},
                    idleTerminationTime: 43200 // One year = 525600 minutes.  One month = 43200 minutes.
                },
                log: []
            };
            this.customFullscreen = this.$mdMedia('xs') || this.$mdMedia('sm');
            console.log('--> DataService started ...');
            $translate('NO_TAG').then(function (translation) {
                _this.noTag = translation;
            });
        }
        DataService.prototype.logAnEvent = function (type, id, diff) {
            var questionId = type === TalkwallApp.LogType.CreateTask ? id : this.data.question._id;
            this.data.log.push(new TalkwallApp.LogEntry(type, id, this.data.status.nickname, questionId, diff));
        };
        DataService.prototype.toggleMagnifyBoard = function () {
            this.data.status.magnifyBoard = !this.data.status.magnifyBoard;
        };
        DataService.prototype.restrictRequests = function () {
            var _this = this;
            if (this.restrictTimerHandle !== null) {
                this.$timeout.cancel(this.restrictTimerHandle);
            }
            this.data.status.restrictPositionRequests = true;
            this.restrictTimerHandle = this.$timeout(function () {
                _this.data.status.restrictPositionRequests = false;
                _this.sendPendingPositionUpdates();
                console.log('Sending pending position updates');
            }, 3000);
        };
        ;
        // Remove token string from the address bar. Then, if authorised, get the user model and the most recent wall
        // Otherwise, follow on back to where we came from..
        DataService.prototype.checkAuthentication = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            var tKey = 'authenticationToken', tokenKey = 'token';
            this.data.status.phoneMode = this.$mdMedia('max-width: 960px');
            var tokenParam = this.$routeParams[tKey] || '';
            if (this.data.status.joinedWithPin) {
                this.$window.sessionStorage.setItem(tokenKey, '');
            }
            if (tokenParam !== '' && !this.data.status.joinedWithPin) {
                //look at the route params first for 'authenticationToken'
                console.log('--> DataService: token from parameter');
                this.$window.sessionStorage.setItem(tokenKey, tokenParam);
                //this will reload the page, clearing the token parameter. next time around it will hit the next 'else if'
                this.$location.search(tKey, null);
            }
            else if (this.$window.sessionStorage.getItem(tokenKey) !== '' && !this.data.status.joinedWithPin) {
                //look at the window session object for the token. time to load the question
                console.log('--> DataService: token already exists');
                this.requestUser(function (user) {
                    _this.data.status.nickname = user.nickname;
                    _this.data.status.authorised = true;
                    if (user.lastOpenedWall === null) {
                        _this.createWall(successCallbackFn, errorCallbackFn);
                    }
                    else {
                        _this.$mdDialog.show({
                            controller: TalkwallApp.ArchiveWallController,
                            controllerAs: 'archiveWallC',
                            templateUrl: 'js/components/archive/archive.html',
                            parent: angular.element(document.body),
                            clickOutsideToClose: true
                        }).then(function (answer) {
                            //dialog answered
                            console.log('--> DataService: ArchiveWallController: answer: ' + answer);
                            if (answer === 'continue') {
                                _this.requestWall(user.lastOpenedWall, successCallbackFn, errorCallbackFn);
                            }
                            else {
                                _this.$http.put(_this.urlService.getHost() + '/wall/close/' + user.lastOpenedWall, {
                                    targetEmail: answer
                                })
                                    .then(function () {
                                    console.log('--> DataService: close wall success');
                                    _this.createWall(successCallbackFn, errorCallbackFn);
                                }, function (error) {
                                    console.log('--> DataService: close wall failure: ' + error);
                                    if (typeof errorCallbackFn === "function") {
                                        errorCallbackFn({ status: error.status, message: error.message });
                                    }
                                });
                            }
                        }, function () {
                            //dialog dismissed
                            console.log('--> DataService: ArchiveWallController: dismissed');
                            _this.$window.location.href = _this.urlService.getHost() + '/#/';
                        });
                    }
                }, function () {
                    // We are not authorised for this wall
                    _this.data.status.authorised = false;
                    //TODO: handle get user error
                });
            }
            else {
                // Fall through..
                this.data.status.authorised = false;
                successCallbackFn();
            }
            // Set up listener for disconnect
            this.$window.onbeforeunload = function () {
                var url = _this.urlService.getHost() + '/';
                var clientType = _this.data.status.authorised ? 'disconnectteacher/' : 'disconnect/';
                _this.$http.get(url + clientType + _this.data.status.nickname + '/' + _this.data.wall._id + '/' + _this.data.question._id)
                    .then(function () {
                    this.$window.location.href = url;
                });
            };
            /*
             // Alternative method for disconnect - causes a browser dialog to show and allows time for disconnect request
             let handle = this;
             this.$window.onbeforeunload = function(ev: BeforeUnloadEvent): any {
             let x = logout();
             return x;
             };

             function logout() {
             let url = handle.urlService.getHost() +
             '/disconnect/' + handle.data.status.nickname + '/' + handle.wall.pin + '/' + handle.question._id;
             handle.$window.location.href = handle.urlService.getHost() + '/';
             handle.$http.get(url).then(function() { console.log('disconnect sent'); } );
             return 'Are you sure you want to close Talkwall?';
             }
             */
        };
        DataService.prototype.getAuthenticatedUser = function () {
            return this.data.user;
        };
        DataService.prototype.requestUser = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            //this will return the correct user from the service, based on the req.user object.
            this.$http.get(this.urlService.getHost() + '/user')
                .then(function (result) {
                var resultKey = 'result';
                _this.data.user = result.data[resultKey];
                console.log('--> DataService: requestUser success');
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.data.user);
                }
            }, function (error) {
                console.log('--> DataService: requestUser failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        // For authorised users only
        DataService.prototype.requestWall = function (wallId, successCallbackFn, errorCallbackFn) {
            var _this = this;
            //return the previous wall with a the existing PIN from REDIS (if expired return true)
            this.$http.get(this.urlService.getHost() + '/wall/' + wallId)
                .then(function (result) {
                var resultKey = 'result';
                _this.data.wall = result.data[resultKey];
                console.log('--> DataService: getWall success');
                var question_index = _this.data.wall.questions.length > 0 ? 0 : -1;
                _this.setQuestion(question_index, successCallbackFn, errorCallbackFn);
            }, function (error) {
                console.log('--> DataService: requestWall failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        // For authorised users only
        DataService.prototype.createWall = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            this.$http.post(this.urlService.getHost() + '/wall', { label: "New Wall: " + new Date().toDateString() })
                .then(function (result) {
                var resultKey = 'result';
                _this.data.wall = result.data[resultKey];
                console.log('--> DataService: createWall success');
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.data.wall);
                }
            }, function (error) {
                console.log('--> DataService: createWall failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        // For non-authorised users
        DataService.prototype.getClientWall = function (joinModel, successCallbackFn, errorCallbackFn) {
            var _this = this;
            this.$http.get(this.urlService.getHost() + '/clientwall/' + joinModel.nickname + '/' + joinModel.pin)
                .then(function (success) {
                var resultKey = 'result', dataKey = 'data', statusKey = 'status';
                // The wall is closed
                if (success[statusKey] === 204) {
                    if (_this.data.wall !== null) {
                        _this.data.wall.closed = true;
                    }
                    _this.stopPolling();
                    _this.showClosingDialog();
                }
                else {
                    _this.data.wall = success[dataKey][resultKey];
                    _this.data.status.nickname = joinModel.nickname;
                    console.log('--> DataService: getClientWall success');
                }
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(_this.data.wall);
                }
            }, function (error) {
                // Close client wall if wall was closed by teacher
                _this.data.wall.closed = true;
                _this.stopPolling();
                _this.showClosingDialog();
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        // Accessor functions for passing messages between directives
        DataService.prototype.setMessageToEdit = function (message) {
            if (message === null && this.data.status.messageOrigin === null) {
                //no message, create a new one
                this.data.status.messageToEdit = new TalkwallApp.Message();
                this.data.status.messageToEdit.creator = this.data.status.nickname;
                this.data.status.messageToEdit.origin.push({ nickname: this.data.status.nickname, message_id: null });
                this.data.status.messageToEdit.question_id = this.data.question._id;
            }
            else if (message === null && this.data.status.messageOrigin !== null) {
                //we have an origin to create the new message, clone it
                this.data.status.messageToEdit = new TalkwallApp.Message().createFromOrigin(this.data.status.messageOrigin, this.data.status.nickname);
                this.data.status.updateOrigin = typeof this.data.status.messageOrigin.board[this.data.status.nickname] !== 'undefined';
            }
            else {
                this.data.status.messageToEdit = message;
            }
        };
        DataService.prototype.clearMessageToEdit = function () {
            this.data.status.messageToEdit = null;
        };
        DataService.prototype.getMessageToEdit = function () {
            return this.data.status.messageToEdit;
        };
        DataService.prototype.setMessageOrigin = function (message) {
            this.data.status.messageOrigin = message;
        };
        DataService.prototype.getMessageOrigin = function () {
            return this.data.status.messageOrigin;
        };
        DataService.prototype.getWall = function () {
            return this.data.wall;
        };
        // If we are changing questions, or a new question, set the polling params correctly. Input new question index.
        DataService.prototype.setQuestion = function (newIndex, successCallbackFn, errorCallbackFn) {
            var previous_question_id = 'none', control = 'none';
            this.stopPolling();
            //if no more questions
            if (this.data.wall.questions.length === 0) {
                console.log('--> setQuestion: no more questions ...');
                this.data.question = null;
            }
            // If true, we are changing questions
            if (this.data.question !== null
                && TalkwallApp.UtilityService.getQuestionIndexFromWallById(this.data.question._id, this.data.wall) !== newIndex) {
                previous_question_id = this.data.question._id;
                control = 'change';
            }
            else if (this.data.question === null) {
                control = 'new';
            }
            // Now set the question if we have it available on the client.
            // If not, we will poll anyway, until notification arrives from server of teacher moving to a question
            if (newIndex !== -1 && this.data.wall.questions.length > 0) {
                this.data.question = new TalkwallApp.Question("").updateMe(this.data.wall.questions[newIndex]);
                this.data.status.currentQuestionIndex = newIndex;
                this.data.status.contributors = this.data.question.contributors;
                // Re-do the hashtag list
                this.buildTagArray();
            }
            // Get the whole message list if we are 'new' or 'changing'
            // Notify a change of question if we are the teacher
            if (control !== 'none' && this.data.question !== null) {
                this.getMessages();
                if (this.data.status.authorised) {
                    this.notifyChangedQuestion(this.data.question._id, previous_question_id, null, null);
                }
            }
            // Start polling regardless of the question existing, to enable poll notifications
            if (this.pollingTimerHandle === null) {
                // Make a special poll request without delay, then set up regular polling
                this.requestPoll(previous_question_id, control, null, null);
                this.startPolling();
            }
            if (typeof successCallbackFn === "function") {
                successCallbackFn(this.data.wall);
            }
        };
        DataService.prototype.closeWallNow = function (targetEmail) {
            var handle = this;
            this.data.wall.closed = true;
            this.data.wall.targetEmail = targetEmail;
            this.updateWall(function () {
                handle.$window.location.href = handle.urlService.getHost() + '/#/';
            }, null);
        };
        /*
         getNickname(): string {
         return this.data.status.authorised ? this.data.user.nickname : this.data.status.studentNickname;
         }
         */
        DataService.prototype.updateWall = function (successCallbackFn, errorCallbackFn) {
            this.$http.put(this.urlService.getHost() + '/wall', {
                wall: this.data.wall
            })
                .then(function () {
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            }, function (error) {
                console.log('--> DataService: updateWall failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.notifyChangedQuestion = function (new_question_id, previous_question_id, successCallbackFn, errorCallbackFn) {
            this.$http.get(this.urlService.getHost() + '/change/' + this.data.status.nickname + '/' + this.data.wall._id + '/' + new_question_id + '/' + previous_question_id)
                .then(function () {
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            }, function (error) {
                console.log('--> DataService: notifyChangedQuestion failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        // 'previousQuestionId' to old question index if we are changing questions. Else set it to -1
        // 'question_id' - may not be set when we first enter - a request with 'none' as question_id returns only status
        // 'control' - 'none' is a regular poll, 'new' is the first poll, 'change' we are changing questions
        DataService.prototype.requestPoll = function (previousQuestionId, control, successCallbackFn, errorCallbackFn) {
            var _this = this;
            var question_id = 'none', pollRoute = '/poll/';
            if (this.data.question !== null) {
                question_id = this.data.question._id;
            }
            if (this.data.status.authorised) {
                pollRoute = '/pollteacher/';
            }
            this.$http.get(this.urlService.getHost() + pollRoute + this.data.status.nickname + '/' + this.data.wall._id +
                '/' + question_id + '/' + previousQuestionId + '/' + control)
                .then(function (result) {
                var resultKey = 'result';
                console.log('Polled at ' + TalkwallApp.UtilityService.getFormattedDate(new Date()));
                if (result.data[resultKey] === null) {
                    console.log('The wall does not exist on server');
                    _this.stopPolling();
                }
                else {
                    _this.processUpdatedMessages(result.data[resultKey]);
                }
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            }, function (error) {
                console.log('Poll FAILED at ' + Date.now().toString());
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
            // Send logs to server
            if (this.logCycleCounter === this.constants.constants['POLLS_PER_LOG_ATTEMPT']) {
                this.logCycleCounter = 0;
                if (this.data.log.length > 0) {
                    this.$http.post(this.urlService.getHost() + '/logs/' + this.data.wall._id +
                        '/' + this.data.status.nickname, { logs: this.data.log })
                        .then(function () {
                        console.log('--> DataService: log success');
                    }, function (error) {
                        console.log('--> DataService: log failure: ' + error['message']);
                    });
                }
            }
            else {
                this.logCycleCounter++;
            }
        };
        DataService.prototype.setQuestionToEdit = function (question) {
            this.data.status.questionToEdit = question;
        };
        //generate a new question on server with _id and returns it
        DataService.prototype.addQuestion = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            this.$http.post(this.urlService.getHost() + '/question', { wall_id: this.data.wall._id, question: this.data.status.questionToEdit })
                .then(function (response) {
                var resultKey = 'result', firstQuestion;
                firstQuestion = _this.data.wall.questions.length === 0;
                _this.data.wall.questions.push(response.data[resultKey]);
                _this.logAnEvent(TalkwallApp.LogType.CreateTask, response.data[resultKey]._id, null);
                // If this was the first question, set it
                if (firstQuestion) {
                    _this.setQuestion(0, successCallbackFn, errorCallbackFn);
                }
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            }, function (error) {
                console.log('--> DataService: addQuestion failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.updateQuestion = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            if (this.data.status.questionToEdit === null) {
                errorCallbackFn({ status: '400', message: "question is not defined" });
            }
            this.$http.put(this.urlService.getHost() + '/question', {
                wall_id: this.data.wall._id,
                question: this.data.status.questionToEdit
            })
                .then(function () {
                console.log('updating the question');
                _this.logAnEvent(TalkwallApp.LogType.EditTask, _this.data.status.questionToEdit._id, null);
                if (_this.data.status.questionToEdit._id === _this.data.question._id) {
                    _this.data.question.updateMe(_this.data.status.questionToEdit);
                }
                _this.data.status.questionToEdit.showControls = false;
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            }, function (error) {
                console.log('--> DataService: updateQuestion failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.deleteQuestion = function (question, successCallbackFn, errorCallbackFn) {
            var _this = this;
            //first check if there are existing message for that question
            this.$http.get(this.urlService.getHost() + '/messages/' + question._id)
                .then(function (result) {
                console.log('--> DataService deleteQuestion: deleteQuestion success');
                _this.logAnEvent(TalkwallApp.LogType.DeleteTask, question._id, null);
                var resultKey = 'result';
                if (result.data[resultKey].length === 0) {
                    var new_question_index_1 = _this.data.status.currentQuestionIndex;
                    var deleted_question_index = TalkwallApp.UtilityService.getQuestionIndexFromWallById(question._id, _this.data.wall);
                    _this.data.wall.questions.splice(deleted_question_index, 1);
                    if (new_question_index_1 >= deleted_question_index) {
                        new_question_index_1 = deleted_question_index - 1;
                    }
                    _this.$http.delete(_this.urlService.getHost() + '/question/' + _this.data.wall._id + '/' + question._id)
                        .then(function () {
                        if (new_question_index_1 > -1) {
                            _this.setQuestion(new_question_index_1, null, null);
                        }
                        successCallbackFn(200);
                    }, function () {
                        console.log('Error deleting question');
                    });
                }
                else {
                    successCallbackFn(401);
                }
            }, function (error) {
                console.log('--> DataService deleteQuestion: deleteQuestion failure: ' + error);
                errorCallbackFn(error);
            });
        };
        //generate a new message on server with _id and returns it
        DataService.prototype.addMessage = function (successCallbackFn, errorCallbackFn) {
            var _this = this;
            var nickname = this.data.status.nickname;
            if (this.data.status.messageToEdit === null) {
                errorCallbackFn({ status: '400', message: "message is not defined" });
            }
            this.data.status.messageToEdit.edits.push({ date: new Date(), text: this.data.status.messageToEdit.text });
            if (this.data.status.updateOrigin) {
                // If the message was created from another, add it to the board, it will replace the origin message's location
                this.data.status.messageToEdit.board[this.data.status.nickname] = this.data.status.messageOrigin.board[this.data.status.nickname];
            }
            var clientType = this.data.status.authorised ? '/messageteacher' : '/message';
            this.$http.post(this.urlService.getHost() + clientType, {
                message: this.data.status.messageToEdit,
                wall_id: this.data.wall._id,
                nickname: nickname
            }).then(function (result) {
                var resultKey = 'result';
                _this.data.question.messages.push(new TalkwallApp.Message().updateMe(result.data[resultKey]));
                _this.parseMessageForTags(result.data[resultKey]);
                _this.data.status.messageToEdit = null;
                if (_this.data.status.updateOrigin) {
                    //the new cloned message was created from a message on the board, so remove my nickname from the old one
                    delete _this.data.status.messageOrigin.board[_this.data.status.nickname];
                    _this.$http.put(_this.urlService.getHost() + clientType, {
                        messages: [_this.data.status.messageOrigin],
                        wall_id: _this.data.wall._id,
                        nickname: _this.data.status.nickname,
                        controlString: 'position'
                    })
                        .then(function (response) {
                        var resultKey = 'result';
                        _this.data.status.updateOrigin = false;
                        _this.data.status.messageOrigin = null;
                        //update the messages array with the updated object, so that all references are in turn updated
                        var idKey = '_id';
                        _this.data.question.messages.forEach(function (m) {
                            if (m._id === response.data[resultKey][idKey]) {
                                m.updateMe(response.data[resultKey]);
                            }
                        });
                    }, function (error) {
                        console.log('--> DataService: updateMessage failure: ' + error);
                        //TODO: fire a notification with the problem
                    });
                }
                else {
                    //make sure to reset the message origin ...
                    _this.data.status.messageOrigin = null;
                    _this.data.status.messageToEdit = null;
                }
                if (typeof successCallbackFn === "function") {
                    successCallbackFn();
                }
            }, function (error) {
                console.log('--> DataService: addMessage failure: ' + error);
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.prototype.getMessages = function () {
            var _this = this;
            if (this.data.question !== null) {
                this.$http.get(this.urlService.getHost() + '/messages/' + this.data.question._id)
                    .then(function (result) {
                    _this.data.question.messages = [];
                    var resultKey = 'result';
                    result.data[resultKey].forEach(function (m) {
                        _this.data.question.messages.push(new TalkwallApp.Message().updateMe(m));
                    });
                    _this.buildTagArray();
                    _this.refreshBoardMessages();
                }, function (error) {
                    console.log('--> DataService: getMessages failure: ' + error);
                });
            }
        };
        DataService.prototype.buildTagArray = function () {
            var handle = this;
            this.data.status.tagCounter = {};
            this.data.status.tags = [];
            this.data.question.messages.forEach(function (message) {
                if (!message.deleted) {
                    handle.parseMessageForTags(message);
                }
            });
        };
        DataService.prototype.parseMessageForTags = function (message) {
            var _this = this;
            if (message !== null) {
                var foundTags = this.utilityService.getPossibleTags(message.text);
                if (foundTags.length > 0) {
                    foundTags.forEach(function (tag) {
                        if (_this.data.status.tags.indexOf(tag) === -1) {
                            _this.data.status.tags.push(tag);
                            var tid = [];
                            tid.push(message._id);
                            _this.data.status.tagCounter[tag] = tid;
                        }
                        else {
                            var tid = _this.data.status.tagCounter[tag];
                            if (tid.indexOf(message._id) === -1) {
                                tid.push(message._id);
                                _this.data.status.tagCounter[tag] = tid;
                            }
                        }
                    });
                    console.log('--> Dataservice: parseMessageForTags: ' + foundTags);
                }
                else {
                    if (this.data.status.tags.indexOf(this.noTag) === -1) {
                        this.data.status.tags.push(this.noTag);
                        this.data.status.tagCounter[this.noTag] = [message._id];
                    }
                    else {
                        this.data.status.tagCounter[this.noTag].push(message._id);
                    }
                }
            }
        };
        // Convert position updates from dictionary into an array to send to server
        DataService.prototype.sendPendingPositionUpdates = function () {
            var messages = [];
            for (var message_id in this.data.status.restrictPositionRequestMessages) {
                if (this.data.status.restrictPositionRequestMessages.hasOwnProperty(message_id)) {
                    messages.push(this.data.status.restrictPositionRequestMessages[message_id]);
                }
            }
            this.data.status.restrictPositionRequestMessages = {};
            if (messages.length > 0) {
                this.updateMessages(messages, 'position');
            }
        };
        // Update messages on the server
        DataService.prototype.updateMessages = function (messages, controlString) {
            var _this = this;
            // Queue the updated message to be sent later - this saves unnecessary server polls
            if (this.data.status.restrictPositionRequests && controlString === 'position') {
                messages.forEach(function (message) {
                    _this.data.status.restrictPositionRequestMessages[message._id] = message;
                });
            }
            else {
                // Send updated messages to the server
                var clientType = this.data.status.authorised ? '/messageteacher' : '/message';
                this.$http.put(this.urlService.getHost() + clientType, {
                    messages: messages,
                    wall_id: this.data.wall._id,
                    nickname: this.data.status.selectedParticipant,
                    controlString: controlString
                })
                    .then(function () {
                    _this.clearMessageToEdit();
                    console.log('--> DataService: updateMessage success');
                }, function (error) {
                    console.log('--> DataService: updateMessage failure: ' + error);
                });
            }
        };
        DataService.prototype.getParticipants = function () {
            return this.data.status.participants;
        };
        DataService.prototype.setBoardDivSize = function (newSize) {
            console.log('--> Dataservice: setBoardDivSize: ' + angular.toJson(newSize));
            this.data.status.phoneMode = this.$mdMedia('max-width: 960px');
            this.data.status.boardDivSize = newSize;
        };
        DataService.prototype.getBackgroundColour = function () {
            var bgColourKey = 'BACKGROUND_COLOURS';
            return this.constants.constants[bgColourKey][this.data.status.currentQuestionIndex];
        };
        DataService.prototype.getGridStyle = function (type) {
            var heightKey = 'VIEW_HEIGHT', widthKey = 'VIEW_WIDTH', cpColourKey = 'COMPLEMENTARY_COLOURS';
            if (type === 'horizontal') {
                return {
                    top: Math.floor(this.data.status.boardDivSize[heightKey] / 2) + 'px',
                    position: 'absolute',
                    borderColor: this.constants.constants[cpColourKey][this.data.status.currentQuestionIndex],
                    backgroundColor: this.constants.constants[cpColourKey][this.data.status.currentQuestionIndex],
                    margin: 0
                };
            }
            else {
                return {
                    left: Math.floor(this.data.status.boardDivSize[widthKey] / 2) + 'px',
                    position: 'absolute',
                    borderColor: this.constants.constants[cpColourKey][this.data.status.currentQuestionIndex],
                    backgroundColor: this.constants.constants[cpColourKey][this.data.status.currentQuestionIndex],
                    margin: 0
                };
            }
        };
        //  Run the polling timer
        DataService.prototype.startPolling = function () {
            var handle = this;
            function requestThePoll() {
                handle.requestPoll('none', 'none', null, null);
            }
            // Begin further requests at time intervals
            if (this.pollingTimerHandle === null) {
                this.pollingTimerHandle = this.$interval(requestThePoll, this.constants.constants['POLL_INTERVAL_SECONDS'] * 1000);
            }
        };
        // Stop the polling timer
        DataService.prototype.stopPolling = function () {
            this.$interval.cancel(this.pollingTimerHandle);
            this.pollingTimerHandle = null;
        };
        // Process updated messages retrieved on the poll response
        DataService.prototype.processUpdatedMessages = function (pollUpdateObject) {
            var _this = this;
            // Update participant list
            var participants = Object.keys(pollUpdateObject.status.connected_students);
            this.data.status.participants = participants.concat(Object.keys(pollUpdateObject.status.connected_teachers));
            // We should not be here! Go back to the landing page
            if (this.data.status.participants.indexOf(this.data.status.nickname) === -1) {
                this.$window.location.href = this.urlService.getHost() + '/';
            }
            // Run on teacher connections only
            if (this.data.status.authorised) {
                // Update total number of talkwall users
                this.data.status.totalOnTalkwall = pollUpdateObject.totalOnTalkwall;
                this.data.status.idleTerminationTime = pollUpdateObject.status.idleTerminationTime;
            }
            else {
                // Status update
                if (pollUpdateObject.status.last_update > this.data.status.last_status_update) {
                    this.data.status.last_status_update = pollUpdateObject.status.last_update;
                    // Refresh the wall
                    this.getClientWall({ nickname: this.data.status.nickname, pin: this.data.wall.pin }, function () {
                        // Set a new question if available
                        var new_question_id = pollUpdateObject.status.teacher_current_question;
                        if (new_question_id !== 'none') {
                            var new_question_index = TalkwallApp.UtilityService.getQuestionIndexFromWallById(new_question_id, _this.data.wall);
                            // Trigger a question and message update
                            _this.data.question = null;
                            _this.setQuestion(new_question_index, null, null);
                        }
                    }, null);
                }
            }
            // Check that a deleted user is removed the contributor list
            var self = this;
            function checkAndRemoveDeletedContributor(nickname) {
                var counter = 0, foundIndex = -1;
                self.data.status.contributors.forEach(function (user, index) {
                    if (user === nickname) {
                        foundIndex = index;
                        counter++;
                    }
                });
                if (counter === 1) {
                    self.data.status.contributors.splice(foundIndex, 1);
                }
                counter = 0;
                foundIndex = -1;
                self.data.status.unselected_contributors.forEach(function (user, index) {
                    if (user === nickname) {
                        foundIndex = index;
                        counter++;
                    }
                });
                if (counter === 1) {
                    self.data.status.unselected_contributors.splice(foundIndex, 1);
                }
            }
            // Message notifications (newly created messages)
            for (var message_id in pollUpdateObject.created) {
                var message = new TalkwallApp.Message().updateMe(pollUpdateObject.created[message_id]);
                this.data.question.messages.push(message);
                this.parseMessageForTags(message);
                // Check that the user is in the contributor list
                if (this.data.status.contributors.indexOf(message.creator) === -1) {
                    this.data.status.contributors.push(message.creator);
                }
            }
            // Message notifications (updated messages)
            for (var message_id in pollUpdateObject.updated) {
                var update = pollUpdateObject.updated[message_id];
                var message = this.utilityService.getMessageFromQuestionById(message_id, this.data.question);
                if (message !== null) {
                    switch (pollUpdateObject.updated[message_id].updateType) {
                        case 'edit':
                            message.text = update.text;
                            message.deleted = update.deleted;
                            if (message.deleted) {
                                checkAndRemoveDeletedContributor(message.creator);
                            }
                            break;
                        case 'position':
                            message.updateBoard(update.board, true, this.data.status.nickname);
                            break;
                        case 'mixed':
                            message.text = update.text;
                            message.deleted = update.deleted;
                            if (message.deleted) {
                                checkAndRemoveDeletedContributor(message.creator);
                            }
                            message.updateBoard(update.board, true, this.data.status.nickname);
                            break;
                    }
                }
                this.parseMessageForTags(message);
                this.refreshBoardMessages();
            }
        };
        DataService.prototype.refreshBoardMessages = function () {
            this.$rootScope.$broadcast('talkwallMessageUpdate', this.data.status.selectedParticipant);
        };
        DataService.prototype.showClosingDialog = function () {
            //detects if the device is small
            // let useFullScreen = (this.$mdMedia('sm') || this.$mdMedia('xs'))  && this.customFullscreen;
            var self = this;
            var disconnect = function () {
                var url = self.urlService.getHost() + '/#/';
                self.$http.get(url + 'disconnect/' + self.data.status.nickname + '/' + self.data.wall._id + '/' + self.data.question._id)
                    .then(function () {
                    self.$window.location.href = url;
                }, function () {
                    self.$window.location.href = url;
                });
            };
            //show the dialog
            this.$mdDialog.show({
                controller: TalkwallApp.CloseController,
                controllerAs: 'closeC',
                templateUrl: 'js/components/close/close.html',
                parent: angular.element(document.body),
                clickOutsideToClose: false
            })
                .then(function () {
                console.log('--> ClosingController: answered');
                disconnect();
            }, function () {
                //dialog dismissed
                console.log('--> LandingController: dismissed');
                disconnect();
            });
        };
        DataService.prototype.getExportWall = function (wallId, successCallbackFn, errorCallbackFn) {
            this.$http.get(this.urlService.getHost() + '/export/' + wallId).then(function (success) {
                var resultKey = 'result', dataKey = 'data'; // statusKey = 'status';
                if (typeof successCallbackFn === "function") {
                    successCallbackFn(success[dataKey][resultKey]);
                }
            }, function (error) {
                // Close client wall if wall was closed by teacher
                if (typeof errorCallbackFn === "function") {
                    errorCallbackFn({ status: error.status, message: error.message });
                }
            });
        };
        DataService.$inject = ['$http', '$window', '$routeParams', '$rootScope', '$location', '$interval', '$timeout', '$mdDialog', '$translate',
            'UtilityService', 'URLService', '$mdMedia', 'TalkwallConstants'];
        return DataService;
    }());
    TalkwallApp.DataService = DataService;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="authenticationservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var TokenInterceptor = (function () {
        function TokenInterceptor($q, $window, $location, authenticationService) {
            var _this = this;
            this.$q = $q;
            this.$window = $window;
            this.$location = $location;
            this.authenticationService = authenticationService;
            this.request = function (config) {
                var tKey = 'token', aKey = 'Authorization';
                config.headers = config.headers || {};
                if (_this.$window.sessionStorage[tKey]) {
                    config.headers[aKey] = 'Bearer ' + _this.$window.sessionStorage[tKey];
                }
                return config;
            };
            this.requestError = function (rejection) {
                return _this.$q.reject(rejection);
            };
            this.response = function (response) {
                var tKey = 'token', sKey = 'status';
                if (response !== null && response[sKey] === 200 && _this.$window.sessionStorage[tKey]
                    && !_this.authenticationService.isAuthenticated) {
                    _this.authenticationService.isAuthenticated = true;
                    console.log('TokenInterceptor: client already authenticated: ' + _this.$window.sessionStorage[tKey]);
                }
                return response || _this.$q.when(response);
            };
            this.responseError = function (rejection) {
                var tKey = 'token';
                if (rejection !== null && rejection.status === 401 && (_this.$window.sessionStorage[tKey]
                    || _this.authenticationService.isAuthenticated)) {
                    delete _this.$window.sessionStorage[tKey];
                    _this.authenticationService.isAuthenticated = false;
                    console.log('TokenInterceptor: client NOT authenticated');
                    _this.$location.path("/login");
                }
                return _this.$q.reject(rejection);
            };
            console.log('--> ITokenInterceptor started ...');
        }
        TokenInterceptor.$inject = ['$q', '$window', '$location', 'AuthenticationService'];
        return TokenInterceptor;
    }());
    TalkwallApp.TokenInterceptor = TokenInterceptor;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    AutoResize.$inject = ['$window'];
    function AutoResize($window) {
        var link = function (scope, element, attrs) {
            function initializeWindowSize() {
                var mhKey = 'maxHeight', whKey = 'windowHeight', wwKey = 'windowWidth';
                scope[mhKey] = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight, window.innerHeight);
                scope[whKey] = $window.innerHeight;
                scope[wwKey] = $window.innerWidth;
            }
            initializeWindowSize();
            scope.$watch('__height', function () {
                initializeWindowSize();
            });
            angular.element($window).bind('resize', function () {
                initializeWindowSize();
                return scope.$apply();
            });
        };
        return {
            link: link
        };
    }
    TalkwallApp.AutoResize = AutoResize;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../models/models.ts"/>
/// <reference path="../../services/dataservice.ts"/>
/// <reference path="../../services/utilityservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var FeedMessageController = (function () {
        function FeedMessageController(isolatedScope, dataService, $document, utilityService, $window) {
            this.isolatedScope = isolatedScope;
            this.dataService = dataService;
            this.$document = $document;
            this.utilityService = utilityService;
            this.$window = $window;
            this.showControls = false;
            this.message = isolatedScope.data;
            if (typeof this.message.origin !== 'undefined') {
                if (this.message.board === undefined) {
                    this.message.board = {};
                }
                this.message.isHighlighted = false;
                this.message.isHighlighted = (this.isPinned() && this.message.board[this.isolatedScope.selectedParticipant].highlighted);
            }
        }
        ;
        FeedMessageController.prototype.toggleShowControls = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.showControls = !this.showControls;
        };
        FeedMessageController.prototype.isPinned = function () {
            return (typeof this.message.board !== 'undefined' && typeof this.message.board[this.isolatedScope.selectedParticipant] !== 'undefined');
        };
        FeedMessageController.prototype.deleteMessage = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            //check if I am authenticated viewing the participant, or the actual author
            if (this.message.creator === this.isolatedScope.selectedParticipant) {
                this.message.deleted = true;
                this.dataService.logAnEvent(TalkwallApp.LogType.DeleteMessage, this.message._id, null);
                this.dataService.updateMessages([this.message], 'edit');
            }
            this.showControls = false;
        };
        FeedMessageController.prototype.editMessage = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            // Either we are the creator or teacher is editing another's message
            if (this.message.creator === this.isolatedScope.selectedParticipant) {
                this.dataService.setMessageToEdit(this.message);
            }
            else {
                // Otherwise we are going to clone someone else's message
                this.dataService.setMessageOrigin(this.message);
                this.dataService.setMessageToEdit(null);
            }
            this.isolatedScope.showEditPanel();
            this.showControls = false;
        };
        FeedMessageController.prototype.togglePinMessage = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.isPinned()) {
                delete this.message.board[this.dataService.data.status.selectedParticipant];
                this.dataService.logAnEvent(TalkwallApp.LogType.UnPinMessage, this.message._id, null);
            }
            else {
                this.message.board[this.dataService.data.status.selectedParticipant] = new TalkwallApp.Nickname(this.utilityService.getRandomBetween(45, 55) / 100, this.utilityService.getRandomBetween(45, 55) / 100, false);
                this.dataService.logAnEvent(TalkwallApp.LogType.PinMessage, this.message._id, null);
            }
            this.dataService.updateMessages([this.message], 'position');
            this.showControls = false;
        };
        FeedMessageController.prototype.toggleHighlightMessage = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.message.board[this.dataService.data.status.selectedParticipant].highlighted = !this.message.board[this.dataService.data.status.selectedParticipant].highlighted;
            var highlightLogText = this.message.board[this.dataService.data.status.selectedParticipant].highlighted ? TalkwallApp.LogType.HighlightMessage : TalkwallApp.LogType.UnHighlightMessage;
            this.message.isHighlighted = this.message.board[this.dataService.data.status.selectedParticipant].highlighted;
            this.dataService.logAnEvent(highlightLogText, this.message._id, null);
            this.dataService.updateMessages([this.message], 'position');
            this.showControls = false;
        };
        FeedMessageController.prototype.persistPosition = function (xPercentage, yPercentage, oldPercentagePosition) {
            this.dataService.logAnEvent(TalkwallApp.LogType.MoveMessage, this.message._id, {
                x: oldPercentagePosition.x - xPercentage,
                y: oldPercentagePosition.y - yPercentage,
            });
            this.message.board[this.isolatedScope.selectedParticipant].xpos = xPercentage;
            this.message.board[this.isolatedScope.selectedParticipant].ypos = yPercentage;
            this.dataService.updateMessages([this.message], 'position');
        };
        FeedMessageController.prototype.getPinnedClass = function () {
            if (this.isPinned() && this.isolatedScope.onBoard === 'false') {
                return 'feedMessage-messageSelected';
            }
            else if (this.isolatedScope.onBoard === 'true' && this.message.board[this.isolatedScope.selectedParticipant].highlighted) {
                return 'feedMessage-messageOnBoardSelected';
            }
            else {
                return 'feedMessage-messageNotSelected';
            }
        };
        FeedMessageController.$inject = ['$scope', 'DataService', '$document', 'UtilityService', '$window'];
        return FeedMessageController;
    }());
    function linker(isolatedScope, element, attributes, ctrl) {
        var viewWidthKey = 'VIEW_WIDTH', viewHeightKey = 'VIEW_HEIGHT';
        var messageWidth = element.prop('offsetWidth');
        var messageHeight = element.prop('offsetHeight');
        var currentSize = ctrl.dataService.data.status.boardDivSize;
        var offset = null;
        var pixelPosition = { x: 0, y: 0 };
        var oldPercentagePosition = { x: 0, y: 0 };
        var participant = null;
        /*
        if (isolatedScope.onBoard === 'true') {
            positionMessage();
            //need a watch here, to refresh the position when the selected contributor or message position changes
            isolatedScope.$watch(() => { return ctrl.message.board[isolatedScope.selectedParticipant] }, (newValue) => { positionCSS() }, true);
        }
        */
        isolatedScope.$on("talkwallMessageUpdate", function (event, newParticipant) {
            if (isolatedScope.onBoard === 'true') {
                if (typeof ctrl.message.board !== 'undefined' && typeof ctrl.message.board[newParticipant] !== 'undefined') {
                    participant = ctrl.message.board[newParticipant];
                    setMessageCss();
                }
            }
        });
        function setMessageCss() {
            element.css({
                top: participant.ypos * 100 + '%',
                left: participant.xpos * 100 + '%'
            });
        }
        function positionMessage() {
            element.on('mousedown touchstart', function (event) {
                // Prevent touches from other places
                /*
                if(event.currentTarget['id'].indexOf('message-') === -1) {
                    return;
                }
                */
                currentSize = ctrl.dataService.data.status.boardDivSize;
                messageWidth = element.prop('offsetWidth');
                messageHeight = element.prop('offsetHeight');
                oldPercentagePosition = { x: participant.xpos, y: participant.ypos };
                if (event instanceof MouseEvent) {
                    offset = {
                        x: event.pageX - element.prop('offsetLeft'),
                        y: event.pageY - element.prop('offsetTop'),
                        originalX: event.pageX,
                        originalY: event.pageY
                    };
                    ctrl.$document.on('mousemove', mousemove);
                    element.on('mouseup', mouseup);
                }
                else if (event instanceof TouchEvent) {
                    var offsetLeft = element.prop('offsetLeft');
                    var offsetRight = element.prop('offsetTop');
                    offset = {
                        x: event['targetTouches'][0].pageX - offsetLeft,
                        y: event['targetTouches'][0].pageY - offsetRight,
                        originalX: event.pageX,
                        originalY: event.pageY
                    };
                    element.on('touchmove', touchmove);
                    element.on('touchend', touchend);
                }
                ctrl.dataService.stopPolling();
                ctrl.dataService.restrictRequests();
            });
        }
        function mousemove(event) {
            pixelPosition.x = event.pageX - offset.x;
            pixelPosition.y = event.pageY - offset.y;
            doMove();
        }
        function touchmove(event) {
            event.preventDefault();
            pixelPosition.x = event['targetTouches'][0].pageX - offset.x;
            pixelPosition.y = event['targetTouches'][0].pageY - offset.y;
            doMove();
        }
        function doMove() {
            if (pixelPosition.x < 0) {
                pixelPosition.x = 0;
            }
            if (pixelPosition.x > (currentSize[viewWidthKey] - messageWidth)) {
                pixelPosition.x = (currentSize[viewWidthKey] - messageWidth);
            }
            if (pixelPosition.y < 0) {
                pixelPosition.y = 0;
            }
            if (pixelPosition.y > (currentSize[viewHeightKey] - messageHeight)) {
                pixelPosition.y = (currentSize[viewHeightKey] - messageHeight);
            }
            /*
            element.css({
                top: pixelPosition.y + 'px',
                left: pixelPosition.x + 'px'
            });
            */
            participant.xpos = pixelPosition.x / currentSize[viewWidthKey];
            participant.ypos = pixelPosition.y / currentSize[viewHeightKey];
            setMessageCss();
        }
        function mouseup(event) {
            var diffX = offset.originalX - event.pageX;
            var diffY = offset.originalY - event.pageY;
            //will only persist if move greater than a 10 * 10px box
            if (diffX >= 10 || diffX <= -10 || diffY >= 10 || diffY <= -10) {
                //ctrl.message.board[isolatedScope.selectedParticipant] = participant;
                ctrl.persistPosition(participant.xpos, participant.ypos, oldPercentagePosition);
            }
            ctrl.$document.off('mousemove', mousemove);
            element.off('touchmove', touchmove);
            element.off('mouseup', mouseup);
            ctrl.dataService.startPolling();
        }
        function touchend(event) {
            var diffX = offset.originalX - event.pageX;
            var diffY = offset.originalY - event.pageY;
            //will only persist if move greater than a 10 * 10px box
            if (diffX >= 10 || diffX <= -10 || diffY >= 10 || diffY <= -10) {
                ctrl.persistPosition(participant.xpos, participant.ypos, oldPercentagePosition);
            }
            event.preventDefault();
            ctrl.$document.off('mousemove', mousemove);
            element.off('touchmove', touchmove);
            element.off('touchend', touchend);
            ctrl.dataService.startPolling();
        }
        if (isolatedScope.onBoard === 'true') {
            participant = ctrl.message.board[isolatedScope.selectedParticipant];
            positionMessage();
            setMessageCss();
        }
    }
    //directive declaration
    function FeedMessage() {
        return {
            restrict: 'A',
            scope: {
                data: '=',
                magnified: '=',
                showEditPanel: "&",
                onBoard: "@",
                selectedParticipant: '@'
            },
            templateUrl: 'js/components/feedMessage/feedMessage.html',
            controller: FeedMessageController,
            controllerAs: 'feedMessageC',
            link: linker,
            replace: true
        };
    }
    TalkwallApp.FeedMessage = FeedMessage;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../models/models.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var TaskQuestionController = (function () {
        function TaskQuestionController(isolatedScope, dataService, $mdDialog) {
            this.isolatedScope = isolatedScope;
            this.dataService = dataService;
            this.$mdDialog = $mdDialog;
            this.question = isolatedScope.data;
            this.showControls = false;
        }
        ;
        TaskQuestionController.prototype.deleteQuestion = function (event) {
            console.log('--> TaskController delete');
            var handle = this;
            this.dataService.deleteQuestion(this.question, function (code) {
                if (code === 401) {
                    handle.$mdDialog.show(handle.$mdDialog.alert()
                        .clickOutsideToClose(true)
                        .title('Question not deleted')
                        .textContent('This question contains messages and cannot be deleted anymore.')
                        .ok('OK'));
                }
                else {
                    //200 => set question to 0
                    handle.dataService.setQuestion(0, null, null);
                }
            }, function (error) {
                console.log('--> TaskController deleteQuestion error: ' + error);
            });
        };
        TaskQuestionController.prototype.editQuestion = function () {
            console.log('--> TaskController edit');
            this.dataService.setQuestionToEdit(this.question);
        };
        TaskQuestionController.$inject = ['$scope', 'DataService', '$mdDialog'];
        return TaskQuestionController;
    }());
    //directive declaration
    function TaskQuestion() {
        return {
            restrict: 'A',
            scope: {
                data: '='
            },
            templateUrl: 'js/components/taskQuestion/taskQuestion.html',
            controller: TaskQuestionController,
            controllerAs: 'taskQuestionC',
            replace: true
        };
    }
    TalkwallApp.TaskQuestion = TaskQuestion;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../_references.ts"/>
/// <reference path="../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var WatchBoardSizeController = (function () {
        function WatchBoardSizeController(dataService, $window) {
            this.dataService = dataService;
            this.$window = $window;
        }
        ;
        WatchBoardSizeController.$inject = ['DataService', '$window'];
        return WatchBoardSizeController;
    }());
    function linker(scope, element, attrs, ctrl) {
        var w = angular.element(ctrl.$window);
        scope.getWindowDimensions = function () {
            return {
                'VIEW_HEIGHT': element.prop('offsetHeight'),
                'VIEW_WIDTH': element.prop('offsetWidth')
            };
        };
        scope.$watch(scope.getWindowDimensions, function (newValue, oldValue) {
            ctrl.dataService.setBoardDivSize(newValue);
        }, true);
        w.bind('resize', function () {
            scope.$apply();
        });
        ctrl.dataService.setBoardDivSize(scope.getWindowDimensions());
    }
    function WatchBoardSize() {
        return {
            restrict: 'A',
            controller: WatchBoardSizeController,
            link: linker
        };
    }
    TalkwallApp.WatchBoardSize = WatchBoardSize;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var LoginController = (function () {
        function LoginController($mdDialog) {
            this.$mdDialog = $mdDialog;
            console.log('--> LoginController: started: ');
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        LoginController.prototype.hide = function (response) {
            console.log('--> LoginController: hide');
            this.$mdDialog.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        LoginController.prototype.cancel = function (response) {
            console.log('--> LoginController: cancel');
            this.$mdDialog.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        LoginController.prototype.answer = function (answer) {
            console.log('--> LoginController: answer: ' + answer);
            this.$mdDialog.hide(answer);
        };
        ;
        LoginController.$inject = ['$mdDialog'];
        return LoginController;
    }());
    TalkwallApp.LoginController = LoginController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var JoinController = (function () {
        function JoinController($mdDialog, $document) {
            this.$mdDialog = $mdDialog;
            this.$document = $document;
            this.joinModel = {
                nickname: "",
                pin: NaN
            };
            console.log('--> LoginController: started: ');
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        JoinController.prototype.hide = function (response) {
            console.log('--> JoinController: hide');
            this.$document[0].activeElement['blur']();
            this.$mdDialog.hide();
        };
        ;
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        JoinController.prototype.cancel = function (response) {
            this.$document[0].activeElement['blur']();
            console.log('--> JoinController: cancel');
            this.$mdDialog.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        JoinController.prototype.answer = function () {
            if (this.joinModel.nickname.length > 0 && this.joinModel.pin > 999 && this.joinModel.pin < 10000) {
                this.$document[0].activeElement['blur']();
                this.$mdDialog.hide(this.joinModel);
            }
        };
        ;
        JoinController.$inject = ['$mdDialog', '$document'];
        return JoinController;
    }());
    TalkwallApp.JoinController = JoinController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../login/login.ts"/>
/// <reference path="../join/join.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var LandingController = (function () {
        function LandingController(urlService, $translate, $mdMedia, $mdDialog, $window, dataService) {
            this.urlService = urlService;
            this.$translate = $translate;
            this.$mdMedia = $mdMedia;
            this.$mdDialog = $mdDialog;
            this.$window = $window;
            this.dataService = dataService;
            this.languageCode = 'no';
            console.log('--> LandingController: started');
            var langKey = 'lang';
            this.languageCode = this.$window.sessionStorage[langKey];
            this.$translate.use(this.languageCode);
            this.customFullscreen = this.$mdMedia('xs') || this.$mdMedia('sm');
        }
        /**
         * display an advanced dialog for the login, and catches it's events
         */
        LandingController.prototype.showLoginDialog = function (ev) {
            var _this = this;
            var handle = this;
            //detects if the device is small
            var useFullScreen = (this.$mdMedia('sm') || this.$mdMedia('xs')) && this.customFullscreen;
            //show the dialog
            this.$mdDialog.show({
                controller: TalkwallApp.LoginController,
                controllerAs: 'loginC',
                templateUrl: 'js/components/login/login.html',
                targetEvent: ev,
                clickOutsideToClose: true
            })
                .then(function (answer) {
                _this.$window.blur();
                //dialog answered
                console.log('--> LandingController: answer: ' + answer);
                handle.$window.location.href = handle.urlService.getHost() + answer;
            }, function () {
                _this.$window.blur();
                //dialog dismissed
                console.log('--> LandingController: dismissed');
            });
        };
        ;
        /**
         * display dialog for joining with pin and nickname
         */
        LandingController.prototype.showJoinDialog = function (ev) {
            var _this = this;
            var handle = this;
            //detects if the device is small
            var useFullScreen = (this.$mdMedia('sm') || this.$mdMedia('xs')) && this.customFullscreen;
            //show the dialog
            this.$mdDialog.show({
                controller: TalkwallApp.JoinController,
                controllerAs: 'joinC',
                templateUrl: 'js/components/join/join.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                clickOutsideToClose: true
            })
                .then(function (joinModel) {
                _this.$window.blur();
                handle.dataService.getClientWall(joinModel, function () {
                    handle.dataService.data.status.joinedWithPin = true;
                    handle.$window.location.href = handle.urlService.getHost() + '/#/wall';
                }, null);
            }, function () {
                _this.$window.blur();
                //dialog dismissed
                console.log('--> LandingController: dismissed');
            });
        };
        LandingController.$inject = ['URLService', '$translate', '$mdMedia', '$mdDialog', '$window', 'DataService'];
        return LandingController;
    }());
    TalkwallApp.LandingController = LandingController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../models/models.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var ExportController = (function () {
        function ExportController(dataService, $routeParams, $mdDialog) {
            this.dataService = dataService;
            this.$routeParams = $routeParams;
            this.$mdDialog = $mdDialog;
            this.wall = null;
            this.selectedQuestionIndex = -1;
            console.log('--> ExportController: started');
            var handle = this;
            var wallKey = 'wid';
            var tokenParam = this.$routeParams[wallKey] || '';
            if (tokenParam !== '') {
                //look at the route params first for wall id
                console.log('--> DataService: token from parameter: ' + tokenParam);
                this.dataService.getExportWall(tokenParam, function (wall) {
                    handle.wall = wall;
                    //handle.wallDate = handle.getFormattedDate();
                }, function (error) {
                    console.log('--> ExportController: getExportWall: error: ' + angular.toJson(error));
                });
            }
            else {
                //no wall id provided, show an alert
                this.$mdDialog.show(this.$mdDialog.alert()
                    .clickOutsideToClose(true)
                    .title('Wall ID missing')
                    .textContent('Please provide a valid wall ID to export its content.' +
                    'The URL should be in the form: http://...talkwall.net/#/export?wid=WALL_ID')
                    .ok('OK'));
            }
        }
        ExportController.prototype.getFormattedDate = function (date) {
            if (date !== null) {
                return moment(date).format('DD/MM/YYYY - HH:mm');
            }
        };
        ExportController.prototype.getBoardMessagesForParticipant = function (participant, qid) {
            var result = new Array();
            var leftSorting = {};
            var rightSorting = {};
            var targetQuestion;
            this.wall.questions.forEach(function (question) {
                if (question._id === qid) {
                    targetQuestion = question;
                }
            });
            targetQuestion.messages.forEach(function (message) {
                if (message.board !== undefined && message.board[participant] !== undefined) {
                    if (message.board[participant].xpos < 0.5) {
                        leftSorting[message.board[participant].ypos] = message;
                    }
                    else {
                        rightSorting[message.board[participant].ypos] = message;
                    }
                }
            });
            var leftKeys = Object.keys(leftSorting);
            var rightKeys = Object.keys(rightSorting);
            for (var i = 0; i < leftKeys.length; i++) {
                result.push(leftSorting[leftKeys[i]]);
            }
            for (var i = 0; i < rightKeys.length; i++) {
                result.push(rightSorting[rightKeys[i]]);
            }
            return result;
        };
        ExportController.$inject = ['DataService', '$routeParams', '$mdDialog'];
        return ExportController;
    }());
    TalkwallApp.ExportController = ExportController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var EditMessageController = (function () {
        function EditMessageController($mdBottomSheet, $document, $timeout, dataService) {
            var _this = this;
            this.$mdBottomSheet = $mdBottomSheet;
            this.$document = $document;
            this.$timeout = $timeout;
            this.dataService = dataService;
            this.boxHook = null;
            console.log('--> EditMessageController: started: ');
            this.messageToEdit = dataService.getMessageToEdit();
            this.$timeout(function () {
                _this.$document[0].activeElement['focus']();
            }, 100);
        }
        /**
         * hide this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        /*
        hide(response?: any): void {
            console.log('--> EditMessageController: hide');
            this.dataService.setMessageToEdit(null);
            this.$document[0].activeElement['blur']();
            this.$mdBottomSheet.hide();
        };
        */
        /**
         * cancel this dialog (see angular.material.IDialogService)
         * @aparam response a possible reponse
         */
        EditMessageController.prototype.cancel = function (response) {
            console.log('--> EditMessageController: cancel');
            this.dataService.setMessageToEdit(null);
            this.$document[0].activeElement['blur']();
            this.$mdBottomSheet.cancel();
        };
        ;
        /**
         * answer this dialog
         * @aparam answer aa a string
         */
        EditMessageController.prototype.answer = function () {
            console.log('--> EditMessageController: answered: ');
            this.$document[0].activeElement['blur']();
            this.$mdBottomSheet.hide();
        };
        ;
        EditMessageController.$inject = ['$mdBottomSheet', '$document', '$timeout', 'DataService'];
        return EditMessageController;
    }());
    TalkwallApp.EditMessageController = EditMessageController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../../services/dataservice.ts"/>
/// <reference path="../../services/utilityservice.ts"/>
/// <reference path="../editMessagePanel/editMessagePanel.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var WallController = (function () {
        function WallController(dataService, $mdSidenav, $mdBottomSheet, $translate, $scope, $timeout, urlService, $window, utilityService) {
            var _this = this;
            this.dataService = dataService;
            this.$mdSidenav = $mdSidenav;
            this.$mdBottomSheet = $mdBottomSheet;
            this.$translate = $translate;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.urlService = urlService;
            this.$window = $window;
            this.utilityService = utilityService;
            this.magnified = false;
            this.magnifyBoard = false;
            this.feedView = true;
            this.rightMenu1 = false;
            this.rightMenu2 = false;
            this.rightMenu3 = false;
            this.rightMenu4 = false;
            this.owneremail = undefined;
            this.savedGridType = 'none';
            this.noTag = 'no tag';
            console.log('--> WallController: started: ');
            $translate('NO_TAG').then(function (translation) {
                _this.noTag = translation;
            });
            this.dataService.checkAuthentication(function () {
                _this.activate();
            }, null);
        }
        WallController.prototype.magnifyTheBoard = function () {
            this.magnifyBoard = !this.magnifyBoard;
        };
        WallController.prototype.activate = function () {
            var _this = this;
            if (this.dataService.data.wall === null) {
                this.$window.location.href = this.urlService.getHost() + '/#/';
            }
            else {
                var question_index = this.dataService.data.wall.questions.length > 0 ? 0 : -1;
                this.setQuestion(question_index, null);
                this.selectedParticipant = this.dataService.data.status.nickname;
                this.dataService.data.status.selectedParticipant = this.selectedParticipant;
                this.$scope.$watch(function () { return _this.selectedParticipant; }, function (newVar, oldVar) {
                    if (newVar !== oldVar) {
                        _this.dataService.data.status.selectedParticipant = newVar;
                        _this.dataService.refreshBoardMessages();
                    }
                }, true);
                if (this.dataService.data.status.authorised &&
                    this.dataService.getAuthenticatedUser().defaultEmail !== undefined &&
                    this.dataService.getAuthenticatedUser().defaultEmail !== '') {
                    this.owneremail = this.dataService.getAuthenticatedUser().defaultEmail;
                }
                var handle_1 = this;
                //contributor filtering (for messages on the board)
                this.messageFilterByContributorOnBoard = function (message) {
                    return (!message.deleted &&
                        !handle_1.dataService.data.status.phoneMode &&
                        typeof message.board !== 'undefined' &&
                        typeof message.board[handle_1.selectedParticipant] !== 'undefined' &&
                        handle_1.dataService.data.status.unselected_contributors.indexOf(message.creator) === -1 &&
                        handle_1.messageTagsNotPresent(message));
                };
                //author+tag filtering (for messages in the feed)
                this.messageFilterByAuthorAndTag = function (message) {
                    return (!message.deleted && handle_1.dataService.data.status.unselected_contributors.indexOf(message.creator) === -1 && handle_1.messageTagsNotPresent(message));
                };
                this.$timeout(function () {
                    _this.showFeed(null);
                    _this.rightMenu1 = true;
                    if (_this.dataService.data.status.authorised && _this.dataService.data.question !== null) {
                        _this.$mdSidenav('right').open();
                    }
                }, 2000);
            }
        };
        WallController.prototype.messageTagsNotPresent = function (message) {
            var messageTags = this.utilityService.getPossibleTags(message.text);
            if (messageTags.length > 0) {
                var present = false;
                for (var i = 0; i < messageTags.length; i++) {
                    if (this.dataService.data.status.unselected_tags.indexOf(messageTags[i]) === -1) {
                        present = true;
                    }
                }
                return present;
            }
            else {
                return this.dataService.data.status.unselected_tags.indexOf(this.noTag) === -1;
            }
        };
        WallController.prototype.showFeed = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.feedView = true;
            this.selectedParticipant = this.dataService.data.status.nickname;
            this.dataService.data.status.selectedParticipant = this.selectedParticipant;
            this.$mdSidenav('left').open();
        };
        WallController.prototype.showScreenContributors = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.magnified = false;
            this.feedView = false;
            this.$mdSidenav('left').open();
        };
        WallController.prototype.setQuestion = function (index, event) {
            var _this = this;
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.dataService.setQuestion(index, function () {
                if (_this.dataService.data.status.currentQuestionIndex !== -1) {
                    _this.savedGridType = _this.dataService.data.question.grid;
                }
            }, function () {
                //error
            });
        };
        WallController.prototype.closeWall = function (targetEmail, event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.dataService.closeWallNow(targetEmail);
            this.owneremail = undefined;
        };
        WallController.prototype.setGrid = function (type, event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.dataService.data.status.questionToEdit.grid = type;
        };
        WallController.prototype.questionToEditDirty = function () {
            if (this.dataService.data.status.questionToEdit === null || this.dataService.data.question === null) {
                return true;
            }
            else {
                return (this.dataService.data.status.questionToEdit.label !== this.dataService.data.question.label
                    && this.dataService.data.status.questionToEdit.label !== '')
                    || typeof this.dataService.data.status.questionToEdit._id !== 'undefined';
            }
        };
        /**** contributor filtering ******/
        WallController.prototype.contributorExists = function (item) {
            return this.dataService.data.status.unselected_contributors.indexOf(item) === -1;
        };
        ;
        WallController.prototype.contributorToggle = function (item, event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            var idx = this.dataService.data.status.unselected_contributors.indexOf(item);
            if (idx > -1) {
                this.dataService.data.status.unselected_contributors.splice(idx, 1);
            }
            else {
                this.dataService.data.status.unselected_contributors.push(item);
            }
        };
        ;
        WallController.prototype.aContributorIsChecked = function () {
            return this.dataService.data.status.unselected_contributors.length < this.dataService.data.status.contributors.length;
        };
        ;
        WallController.prototype.toggleAllContributors = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.dataService.data.status.unselected_contributors.length === this.dataService.data.status.contributors.length) {
                this.dataService.data.status.unselected_contributors = [];
            }
            else {
                this.dataService.data.status.unselected_contributors = this.dataService.data.status.contributors.slice(0);
            }
        };
        ;
        /**** end contributor filtering ******/
        /**** tag filtering ******/
        WallController.prototype.tagExists = function (item) {
            return this.dataService.data.status.unselected_tags.indexOf(item) === -1;
        };
        ;
        WallController.prototype.tagToggle = function (item, event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            var idx = this.dataService.data.status.unselected_tags.indexOf(item);
            if (idx > -1) {
                this.dataService.data.status.unselected_tags.splice(idx, 1);
            }
            else {
                this.dataService.data.status.unselected_tags.push(item);
            }
        };
        ;
        WallController.prototype.tagIsChecked = function () {
            return this.dataService.data.status.unselected_tags.length !== this.dataService.data.status.tags.length;
        };
        ;
        WallController.prototype.toggleAllTags = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.dataService.data.status.unselected_tags.length === this.dataService.data.status.tags.length) {
                this.dataService.data.status.unselected_tags = [];
            }
            else {
                this.dataService.data.status.unselected_tags = this.dataService.data.status.tags.slice(0);
            }
        };
        ;
        /**** end tag filtering ******/
        WallController.prototype.showMessageEditor = function (newMessage) {
            var _this = this;
            var handle = this;
            if (newMessage) {
                handle.dataService.setMessageToEdit(null);
            }
            //this.dataService.stopPolling();
            //this.showFeed(null);
            this.$mdBottomSheet.show({
                controller: TalkwallApp.EditMessageController,
                controllerAs: 'editMessageC',
                clickOutsideToClose: false,
                templateUrl: 'js/components/editMessagePanel/editMessagePanel.html'
            }).then(function () {
                //dialog answered
                _this.$window.document.activeElement['blur']();
                //post message to server and add returned object to question feed
                var message = handle.dataService.getMessageToEdit();
                if (message !== null) {
                    if (typeof message._id === 'undefined') {
                        console.log('--> WallController: Edit message - created');
                        _this.dataService.logAnEvent(TalkwallApp.LogType.CreateMessage, message._id, null);
                        handle.dataService.addMessage(function () {
                            //success
                        }, function () {
                            //TODO: handle message create error
                        });
                    }
                    else {
                        console.log('--> WallController: Edit message - edited');
                        _this.dataService.logAnEvent(TalkwallApp.LogType.EditMessage, message._id, null);
                        handle.dataService.updateMessages([message], 'edit');
                    }
                }
                //handle.dataService.startPolling();
            }, function () {
                //dialog dismissed
                _this.$window.document.activeElement['blur']();
                console.log('--> WallController: Edit message dismissed');
                handle.dataService.clearMessageToEdit();
                //handle.dataService.startPolling();
            });
        };
        WallController.prototype.closeLeftSidenav = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.$mdSidenav('left').close();
            this.magnified = false;
        };
        WallController.prototype.toggleMagnified = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.magnified = !this.magnified;
        };
        WallController.prototype.toggleRightMenu = function (n, event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('--> WallController: toggleRightMenu: ' + n);
            switch (n) {
                case 1:
                    this.rightMenu1 = !this.rightMenu1;
                    this.rightMenu2 = false;
                    this.rightMenu3 = false;
                    this.rightMenu4 = false;
                    break;
                case 2:
                    this.rightMenu1 = false;
                    this.rightMenu2 = !this.rightMenu2;
                    this.rightMenu3 = false;
                    this.rightMenu4 = false;
                    //this.selected_users = this.dataService.getParticipants().slice(0);
                    break;
                case 3:
                    this.rightMenu1 = false;
                    this.rightMenu2 = false;
                    this.rightMenu3 = !this.rightMenu3;
                    this.rightMenu4 = false;
                    break;
                case 4:
                    this.rightMenu1 = false;
                    this.rightMenu2 = false;
                    this.rightMenu3 = false;
                    this.rightMenu4 = !this.rightMenu4;
                    break;
                default:
                    this.rightMenu1 = false;
                    this.rightMenu2 = false;
                    this.rightMenu3 = false;
                    this.rightMenu4 = false;
            }
        };
        WallController.prototype.addQuestion = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.dataService.data.status.questionToEdit = new TalkwallApp.Question('');
            this.dataService.data.status.questionToEdit.isNew = true;
        };
        WallController.prototype.cancelEditQuestion = function (event) {
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.dataService.data.status.questionToEdit = null;
        };
        WallController.prototype.saveQuestion = function (event) {
            var _this = this;
            if (event !== null) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.dataService.data.status.questionToEdit.isNew) {
                this.dataService.addQuestion(function () {
                    //set to the new question if none
                    if (_this.dataService.data.question === null) {
                        _this.setQuestion(0, null);
                    }
                    //clear the question to edit ...
                    _this.dataService.setQuestionToEdit(null);
                }, function () {
                    //TODO: handle question retrieval error
                });
            }
            else {
                this.dataService.updateQuestion(function () {
                    //set to the new question if none
                    if (_this.dataService.data.question === null) {
                        _this.setQuestion(0, null);
                    }
                    //clear the question to edit ...
                    _this.dataService.setQuestionToEdit(null);
                }, function () {
                    //TODO: handle question retrieval error
                });
            }
        };
        WallController.$inject = ['DataService', '$mdSidenav', '$mdBottomSheet', '$translate', '$scope', '$timeout', 'URLService', '$window', 'UtilityService'];
        return WallController;
    }());
    TalkwallApp.WallController = WallController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="../../_references.ts"/>
/// <reference path="../../services/urlservice.ts"/>
/// <reference path="../login/login.ts"/>
/// <reference path="../join/join.ts"/>
/// <reference path="../../services/dataservice.ts"/>
var TalkwallApp;
(function (TalkwallApp) {
    "use strict";
    var SessionInfoController = (function () {
        function SessionInfoController(urlService, $translate, $http, $window, $interval) {
            this.urlService = urlService;
            this.$translate = $translate;
            this.$http = $http;
            this.$window = $window;
            this.$interval = $interval;
            this.languageCode = 'no';
            var langKey = 'lang';
            this.languageCode = this.$window.sessionStorage[langKey];
            this.$translate.use(this.languageCode);
            this.data = {
                pin: '',
                error: '',
                showResult: false,
                wall: TalkwallApp.Wall,
                name: ''
            };
            this.datestring = '';
            this.timestring = '';
            this.clapper = 'images/clapper1.png';
        }
        SessionInfoController.prototype.activate = function () {
            var _this = this;
            this.$http.get(this.urlService.getHost() + '/clientwall/none/' + this.data.pin)
                .then(function (success) {
                _this.data.wall = success['data']['result'];
                if (_this.data.wall.createdBy.google.hasOwnProperty('name')) {
                    _this.data.name = _this.data.wall.createdBy.google.name;
                }
                else if (_this.data.wall.createdBy.facebook.hasOwnProperty('name')) {
                    _this.data.name = _this.data.wall.createdBy.facebook.name;
                }
                else if (_this.data.wall.createdBy.local.hasOwnProperty('name')) {
                    _this.data.name = _this.data.wall.createdBy.local.name;
                }
                _this.data.showResult = true;
                SessionInfoController.GetClock();
                _this.$interval(function () {
                    var data = SessionInfoController.GetClock();
                    _this.datestring = data.date;
                    _this.timestring = data.time;
                    _this.clapper = _this.clapper === 'images/clapper1.png' ? 'images/clapper2.png' : 'images/clapper1.png';
                }, 1000);
            }, function () {
                _this.data.error = 'No session found';
            });
        };
        SessionInfoController.GetClock = function () {
            var tday = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var tmonth = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            var d = new Date();
            var nday = d.getDay(), nmonth = d.getMonth(), ndate = d.getDate(), nyear = d.getFullYear();
            if (nyear < 1000) {
                nyear += 1900;
            }
            var nhour = d.getHours(), nmin = d.getMinutes(), nsec = d.getSeconds(), ap, nminString, nsecString;
            if (nhour == 0) {
                ap = " AM";
                nhour = 12;
            }
            else if (nhour < 12) {
                ap = " AM";
            }
            else if (nhour == 12) {
                ap = " PM";
            }
            else if (nhour > 12) {
                ap = " PM";
                nhour -= 12;
            }
            nminString = (nmin <= 9) ? "0" + nmin : nmin;
            nsecString = (nsec <= 9) ? "0" + nsec : nsec;
            return { date: tday[nday] + ", " + tmonth[nmonth] + " " + ndate + ", " + nyear,
                time: nhour + ":" + nminString + ":" + nsecString + ap + "" };
        };
        SessionInfoController.$inject = ['URLService', '$translate', '$http', '$window', '$interval'];
        return SessionInfoController;
    }());
    TalkwallApp.SessionInfoController = SessionInfoController;
})(TalkwallApp || (TalkwallApp = {}));
/// <reference path="_references.ts"/>
/// <reference path="app.config.ts"/>
/// <reference path="app.constants.ts"/>
/// <reference path="services/dataservice.ts"/>
/// <reference path="services/authenticationservice.ts"/>
/// <reference path="services/tokenservice.ts"/>
/// <reference path="services/urlservice.ts"/>
/// <reference path="services/utilityservice.ts"/>
/// <reference path="directives/autoresize.ts"/>
/// <reference path="components/feedMessage/feedMessage.ts"/>
/// <reference path="components/taskQuestion/taskQuestion.ts"/>
/// <reference path="directives/watchboardsize.ts"/>
/// <reference path="components/login/login.ts"/>
/// <reference path="components/join/join.ts"/>
/// <reference path="components/landing/landing.ts"/>
/// <reference path="components/archive/archive.ts"/>
/// <reference path="components/export/export.ts"/>
/// <reference path="components/wall/wall.ts"/>
/// <reference path="components/sessioninfo/sessioninfo.ts"/>
/// <reference path="components/editMessagePanel/editMessagePanel.ts"/>
/// <reference path="app.run.ts"/>
/**
 * TalkwallApp core application module.
 * @preferred
 */
var TalkwallApp;
(function (TalkwallApp) {
    'use strict';
    /**
     * Array of dependencies to be injected in the application "dependencies".
     */
    var dependencies = [
        'ngRoute',
        'ngAria',
        'ngAnimate',
        'pascalprecht.translate',
        'ngMaterial'
    ];
    angular.module('TalkwallApp', dependencies)
        .constant('TalkwallConstants', TalkwallApp.TalkwallConstants)
        .config(TalkwallApp.configApp)
        .service('URLService', TalkwallApp.URLService)
        .service('DataService', TalkwallApp.DataService)
        .service('AuthenticationService', TalkwallApp.AuthenticationService)
        .service('TokenInterceptor', TalkwallApp.TokenInterceptor)
        .service('UtilityService', TalkwallApp.UtilityService)
        .directive('autoresize', TalkwallApp.AutoResize)
        .directive('watchBoardSize', TalkwallApp.WatchBoardSize)
        .directive('feedMessage', TalkwallApp.FeedMessage)
        .directive('taskQuestion', TalkwallApp.TaskQuestion)
        .controller('ArchiveWallController', TalkwallApp.ArchiveWallController)
        .controller('LoginController', TalkwallApp.LoginController)
        .controller('JoinController', TalkwallApp.JoinController)
        .controller('CloseController', TalkwallApp.CloseController)
        .controller('LandingController', TalkwallApp.LandingController)
        .controller('SessionInfoController', TalkwallApp.SessionInfoController)
        .controller('ExportController', TalkwallApp.ExportController)
        .controller('WallController', TalkwallApp.WallController)
        .controller('EditMessageController', TalkwallApp.EditMessageController)
        .run(TalkwallApp.runApp);
})(TalkwallApp || (TalkwallApp = {}));
